<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cloud Hopper 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000033;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 100;
        }
        #high-score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 100;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 200;
        }
        #start-screen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff;
        }
        #start-button {
            font-size: 24px;
            padding: 15px 30px;
            background-color: #00aaff;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 10px #00aaff;
            transition: all 0.3s ease;
        }
        #start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00aaff, 0 0 25px #00aaff;
        }
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9); /* Îçî Î∂àÌà¨Î™ÖÌïòÍ≤å */
            z-index: 1000; /* ÏµúÏÉÅÏúÑ Î†àÏù¥Ïñ¥ */
            pointer-events: auto;
        }
        #game-over h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0033, 0 0 20px #ff0033;
            animation: pulsate 1.5s infinite alternate;
        }
        @keyframes pulsate {
            0% { text-shadow: 0 0 10px #ff0033, 0 0 20px #ff0033; }
            100% { text-shadow: 0 0 15px #ff0033, 0 0 30px #ff0033, 0 0 40px #ff0033; }
        }
        #final-score {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        #high-score {
            color: gold;
            font-size: 24px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px gold;
        }
        #restart-button {
            font-size: 24px;
            padding: 15px 30px;
            background-color: #ff0033;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 10px #ff0033;
            transition: all 0.3s ease;
        }
        #restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0033, 0 0 25px #ff0033;
        }
        .instructions {
            color: white;
            max-width: 600px;
            text-align: center;
            margin: 20px 0 30px 0;
            font-size: 18px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-display">Score: 0</div>
        <div id="high-score-display">High Score: 0</div>
        
        <div id="start-screen">
            <h1>Cloud Hopper 3D</h1>
            <div class="instructions">
                <p>Jump from cloud to cloud and don't fall!</p>
                <p>Use LEFT/RIGHT arrow keys to move</p>
                <p>Press UP arrow to jump (press again for double jump)</p>
            </div>
            <button id="start-button">START</button>
        </div>
        
        <div id="game-over">
            <h1>Game Over</h1>
            <div id="final-score">Score: 0</div>
            <div id="high-score">High Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Vibe Jam 2025 Ï∞∏Í∞Ä ÎßÅÌÅ¨ -->
    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>

    <script>
        // DOM ÏöîÏÜå
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const highScoreDisplay = document.getElementById('high-score-display');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScore = document.getElementById('final-score');
        const highScoreElement = document.getElementById('high-score');
        const restartButton = document.getElementById('restart-button');
        
        // ÏãúÏûë Ïãú Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ Ïà®Í∏∞Í∏∞
        gameOverScreen.style.display = 'none';
        
        // Three.js Î≥ÄÏàò
        let scene, camera, renderer;
        let player;
        let clouds = [];
        let planets = []; // ÌñâÏÑ± Î∞∞Ïó¥ Ï∂îÍ∞Ä
        let starField;
        let directionalLight;
        
        // Í≤åÏûÑ Î≥ÄÏàò
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let gameActive = false;
        let isFallingAnimation = false;
        let playerX = 0;
        let playerY = 0;
        let playerZ = 0;
        let velocityY = 0;
        let velocityX = 0;
        let gravity = 0.015;
        let jumpForce = -0.4;
        let isJumping = false;
        let canDoubleJump = false;
        let animationFrameId;
        let cloudCount = 9; // Íµ¨Î¶Ñ Ïàò Ï¶ùÍ∞Ä (6 -> 9)
        let gameSpeed = 0.08; // Ï¥àÍ∏∞ ÏÜçÎèÑ
        let baseGameSpeed = 0.08; // Í∏∞Î≥∏ Í≤åÏûÑ ÏÜçÎèÑ
        
        // ÏµúÏ¥à ÌïòÏù¥Ïä§ÏΩîÏñ¥ ÌëúÏãú
        highScoreDisplay.textContent = `High Score: ${highScore}`;
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        document.addEventListener('keydown', function(event) {
            if (!gameActive) return;
            
            if (event.key === 'ArrowLeft') {
                velocityX = -0.15;
            }
            if (event.key === 'ArrowRight') {
                velocityX = 0.15;
            }
            if (event.key === 'ArrowUp') {
                if (!isJumping) {
                    jump();
                } else if (canDoubleJump) {
                    doubleJump();
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                velocityX = 0;
            }
        });
        
        // Three.js Ï¥àÍ∏∞Ìôî
        function initThree() {
            // Ïî¨ ÏÉùÏÑ±
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000033);
            
            // Ïπ¥Î©îÎùº ÏÉùÏÑ±
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // Î†åÎçîÎü¨ ÏÉùÏÑ±
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            
            // Ï°∞Î™Ö ÏÑ§Ï†ï
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // Í∞úÏÑ†Îêú Ïö∞Ï£º Î∞∞Í≤Ω ÏÉùÏÑ±
            starField = createEnhancedStarField();
            
            // Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // ÏÉàÎ°úÏö¥ Ìï®Ïàò: ÎÜíÏù¥Ïóê Îî∞Î•∏ Í≤åÏûÑ ÏÜçÎèÑ Ï°∞Ï†ï
        function adjustSpeedByHeight() {
            // ÏãúÏûë ÎÜíÏù¥Î•º 0ÏúºÎ°ú Í∏∞Ï§Ä ÏÇºÏùå
            const currentHeight = player.position.y;
            
            // ÎÜíÏù¥Ïóê Îî∞Î•∏ Ï∂îÍ∞Ä ÏÜçÎèÑ (100 Îã®ÏúÑÎßàÎã§ 0.02Ïî© Ï¶ùÍ∞Ä)
            const heightMultiplier = 0.0002;
            const additionalSpeed = currentHeight * heightMultiplier;
            
            // ÏµúÏ¢Ö Í≤åÏûÑ ÏÜçÎèÑ Í≥ÑÏÇ∞ (ÏµúÏÜå ÏÜçÎèÑÎäî baseGameSpeed Ïú†ÏßÄ)
            gameSpeed = baseGameSpeed + additionalSpeed;
            
            // ÏµúÎåÄ ÏÜçÎèÑ Ï†úÌïú (ÎÑàÎ¨¥ Îπ®ÎùºÏßÄÏßÄ ÏïäÎèÑÎ°ù)
            const maxSpeed = 0.3;
            if (gameSpeed > maxSpeed) {
                gameSpeed = maxSpeed;
            }
        }
        
        // Îã§ÏñëÌïú ÏÉâÏÉÅÍ≥º ÌÅ¨Í∏∞Ïùò Î≥ÑÍ≥º ÌñâÏÑ±Ïù¥ ÏûàÎäî Ïö∞Ï£º Î∞∞Í≤Ω ÏÉùÏÑ±
        function createEnhancedStarField() {
            // Í∏∞Ï°¥ Î≥Ñ Î∞∞Í≤Ω ÏÉùÏÑ±
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            
            // Îçî Îã§ÏñëÌïú ÏÉâÏÉÅÏùò Î≥ÑÎì§ ÏÉùÏÑ±
            for (let i = 0; i < starCount; i++) {
                const x = (Math.random() - 0.5) * 1000;
                const y = (Math.random() - 0.5) * 1000;
                const z = (Math.random() - 0.5) * 1000;
                starPositions.push(x, y, z);
                
                // Î≥Ñ ÌÅ¨Í∏∞ Îã§ÏñëÌôî
                const size = Math.random() * 2 + 0.5;
                starSizes.push(size);
                
                // Î≥Ñ ÏÉâÏÉÅ Îã§ÏñëÌôî (Ìù∞ÏÉâ, ÎÖ∏ÎûÄÏÉâ, ÌååÎûÄÏÉâ, Îπ®Í∞ÑÏÉâ Îì±)
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    // ÎåÄÎ∂ÄÎ∂Ñ Ìù∞ÏÉâ~ÎÖ∏ÎûÄÏÉâ Î≥Ñ
                    const shade = 0.7 + Math.random() * 0.3;
                    starColors.push(shade, shade, Math.max(0.7, shade - 0.2));
                } else if (colorChoice < 0.8) {
                    // ÏïΩÍ∞ÑÏùò Ìë∏Î•∏ Î≥Ñ
                    starColors.push(0.7, 0.7, 1);
                } else if (colorChoice < 0.9) {
                    // ÏïΩÍ∞ÑÏùò Î∂âÏùÄ Î≥Ñ
                    starColors.push(1, 0.7, 0.7);
                } else {
                    // ÏïΩÍ∞ÑÏùò Ï≤≠Î°ùÏÉâ Î≥Ñ
                    starColors.push(0.7, 1, 1);
                }
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 1.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            
            // ÌñâÏÑ± Ï∂îÍ∞Ä (ÌîΩÏÖÄÌôîÎêú Ïä§ÌÉÄÏùº)
            addPixelPlanets();
            
            return starField;
        }

        // ÌîΩÏÖÄÌôîÎêú ÌñâÏÑ± Ï∂îÍ∞Ä Ìï®Ïàò
        function addPixelPlanets() {
            // ÌñâÏÑ±Ïùò Ï¢ÖÎ•òÏôÄ ÏÉâÏÉÅ Ï†ïÏùò
            const planetTypes = [
                // Í∏∞Ï°¥ ÌñâÏÑ±Îì§
                { size: 8, color: 0x3498db, position: [-180, 100, -400] },  // ÌååÎûÄÏÉâ ÌñâÏÑ±
                { size: 12, color: 0x8e44ad, position: [200, -150, -350] }, // Î≥¥ÎùºÏÉâ ÌñâÏÑ±
                { size: 6, color: 0x1abc9c, position: [-100, -200, -300] }, // Ï≤≠Î°ùÏÉâ ÌñâÏÑ±
                { size: 10, color: 0xe74c3c, position: [150, 180, -380] },  // Îπ®Í∞ÑÏÉâ ÌñâÏÑ±
                { size: 15, color: 0xf1c40f, position: [-220, -120, -420] }, // ÎÖ∏ÎûÄÏÉâ ÌñâÏÑ±
                { size: 30, color: 0x3498db, position: [400, 50, -600] },   // ÏßÄÍµ¨ (ÌÅ∞ ÌååÎûÄÏÉâ ÌñâÏÑ±)
                { size: 25, color: 0xf39c12, position: [320, -80, -500] },   // ÌÜ†ÏÑ± (ÌÅ∞ Ï£ºÌô©ÏÉâ ÌñâÏÑ±)
                
                // ÏùÄÌïò ÏôºÏ™ΩÏóê Ï∂îÍ∞ÄÌïú ÌñâÏÑ±Îì§
                { size: 18, color: 0xe74c3c, position: [-350, 50, -550] },   // Î∂âÏùÄ ÌôîÏÑ±Ìòï ÌñâÏÑ±
                { size: 5, color: 0xf1c40f, position: [-280, 120, -480] },   // ÏûëÏùÄ ÎÖ∏ÎûÄÏÉâ ÌñâÏÑ±
                { size: 14, color: 0x9b59b6, position: [-400, -100, -520] }, // Î≥¥ÎùºÏÉâ Í∞ÄÏä§Ìòï ÌñâÏÑ±
                { size: 8, color: 0x1abc9c, position: [-320, -180, -450] },  // Ï≤≠Î°ùÏÉâ ÏñºÏùå ÌñâÏÑ±
                { size: 7, color: 0xe67e22, position: [-430, 150, -500] },   // ÏûëÏùÄ Ï£ºÌô©ÏÉâ ÌñâÏÑ±
                { size: 20, color: 0x34495e, position: [-500, -50, -650] },   // Ïñ¥ÎëêÏö¥ Ïô∏Í≥Ω ÌñâÏÑ±
                
                // Í∑†ÌòïÏùÑ ÏúÑÌï¥ Ïò§Î•∏Ï™Ω ÌñâÏÑ±Îì§Í≥º Î∞òÎåÄ ÏúÑÏπòÏóê Ï∂îÍ∞ÄÌï† ÏÉàÎ°úÏö¥ ÌñâÏÑ±Îì§
                { size: 28, color: 0x27ae60, position: [-420, -40, -580] },  // ÌÅ∞ ÎÖπÏÉâ ÌñâÏÑ± (ÏßÄÍµ¨ Î∞òÎåÄÌé∏)
                { size: 22, color: 0xd35400, position: [-380, 100, -520] },  // ÌÅ∞ Ï£ºÌô©-Í∞àÏÉâ ÌñâÏÑ± (ÌÜ†ÏÑ± Î∞òÎåÄÌé∏)
                { size: 16, color: 0xecf0f1, position: [-300, 200, -480] },  // Ï§ëÍ∞Ñ ÌÅ¨Í∏∞ Ìù∞ÏÉâ ÌñâÏÑ±
                { size: 10, color: 0xf1c40f, position: [-250, -220, -400] }, // ÏûëÏùÄ ÎÖ∏ÎûÄÏÉâ ÌñâÏÑ±
                { size: 13, color: 0x2980b9, position: [-450, -150, -550] }  // Ï§ëÍ∞Ñ ÌÅ¨Í∏∞ Ìë∏Î•∏ÏÉâ ÏñºÏùå ÌñâÏÑ±
            ];
            
            // Í∞Å ÌñâÏÑ± ÏÉùÏÑ±
            planetTypes.forEach((planet, index) => {
                let planetMesh;
                
                // ÏßÄÍµ¨ ÌñâÏÑ± (Ïù∏Îç±Ïä§ 5)
                if (index === 5) {
                    // ÏßÄÍµ¨ ÏÉùÏÑ± - ÌîΩÏÖÄÌôîÎêú Î™®ÏäµÏùÑ ÏúÑÌï¥ ÎÇÆÏùÄ ÏÑ∏Í∑∏Î®ºÌä∏ Ïàò ÏÇ¨Ïö©
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    
                    // ÌîΩÏÖÄÌôîÎêú ÏßÄÍµ¨ Ïû¨Ïßà
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.7,
                        metalness: 0.3
                    });
                    
                    // ÏßÄÍµ¨ ÎåÄÎ•ô Ìö®Í≥ºÎ•º ÏúÑÌïú Ï∂îÍ∞Ä ÎîîÌÖåÏùº
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ÎåÄÎ•ôÏùÑ ÌëúÌòÑÌïòÍ∏∞ ÏúÑÌïú ÎûúÎç§ Ìå®ÌÑ¥
                    const continentGeometry = new THREE.IcosahedronGeometry(planet.size * 1.01, 1);
                    const continentMaterial = new THREE.MeshStandardMaterial({
                        color: 0x2ecc71, // Ï¥àÎ°ùÏÉâ ÎåÄÎ•ô
                        flatShading: true,
                        roughness: 0.9,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    // ÎåÄÎ•ô Î©îÏãú Î≥ÄÌòïÌïòÏó¨ ÏùºÎ∂ÄÎßå Î≥¥Ïù¥Í≤å
                    const continentMesh = new THREE.Mesh(continentGeometry, continentMaterial);
                    
                    // Ï†ïÏ†ê ÏùºÎ∂ÄÎßå Î≥¥Ïù¥Í≤å Ï°∞Ï†à
                    const positionAttribute = continentGeometry.getAttribute('position');
                    const vertex = new THREE.Vector3();
                    
                    // Î≤ÑÌÖçÏä§ ÏûëÏóÖÏùÑ ÏúÑÌïú ÏûÑÏãú Î∞∞Ïó¥
                    const positions = [];
                    const visible = [];
                    
                    for (let i = 0; i < positionAttribute.count; i++) {
                        visible.push(Math.random() > 0.6); // 60% ÌôïÎ•†Î°ú ÎåÄÎ•ô Î∂ÄÎ∂Ñ Ïà®ÍπÄ
                        
                        vertex.fromBufferAttribute(positionAttribute, i);
                        if (!visible[i]) {
                            // Ìï¥Îãπ Î≤ÑÌÖçÏä§ ÏïàÎ≥¥Ïù¥Í≤å (Î¨º ÏÜçÏúºÎ°ú)
                            vertex.multiplyScalar(0.98);
                        }
                        
                        positions.push(vertex.x, vertex.y, vertex.z);
                    }
                    
                    continentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    planetMesh.add(continentMesh);
                }
                // ÌÜ†ÏÑ± ÌñâÏÑ± (Ïù∏Îç±Ïä§ 6)
                else if (index === 6) {
                    // ÌÜ†ÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ÌÜ†ÏÑ± Í≥†Î¶¨ Ï∂îÍ∞Ä
                    const ringGeometry = new THREE.RingGeometry(planet.size * 1.3, planet.size * 1.7, 32);
                    const ringMaterial = new THREE.MeshStandardMaterial({
                        color: 0xf5deb3,
                        flatShading: true,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2.5; // Í≥†Î¶¨ Í∏∞Ïö∏Ïù¥Í∏∞
                    planetMesh.add(ring);
                    
                    // Ï∂îÍ∞Ä ÏñáÏùÄ Í≥†Î¶¨
                    const thinRingGeometry = new THREE.RingGeometry(planet.size * 1.8, planet.size * 1.85, 32);
                    const thinRingMaterial = new THREE.MeshStandardMaterial({
                        color: 0xd2b48c,
                        flatShading: true,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const thinRing = new THREE.Mesh(thinRingGeometry, thinRingMaterial);
                    thinRing.rotation.x = Math.PI / 2.5;
                    planetMesh.add(thinRing);
                }
                // Î∂âÏùÄ ÌôîÏÑ±Ìòï ÌñâÏÑ± (Ïù∏Îç±Ïä§ 7)
                else if (index === 7) {
                    // ÌôîÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.9,
                        metalness: 0.1
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ÌëúÎ©¥ ÌÅ¨Î†àÏù¥ÌÑ∞ Ï∂îÍ∞Ä
                    for (let i = 0; i < 12; i++) {
                        const craterSize = planet.size * (Math.random() * 0.1 + 0.05);
                        const craterGeometry = new THREE.CircleGeometry(craterSize, 8);
                        const craterMaterial = new THREE.MeshStandardMaterial({
                            color: 0xc0392b,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const crater = new THREE.Mesh(craterGeometry, craterMaterial);
                        
                        // ÎûúÎç§ ÏúÑÏπòÏóê ÌÅ¨Î†àÏù¥ÌÑ∞ Î∞∞Ïπò
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        crater.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        crater.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        crater.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // ÌÅ¨Î†àÏù¥ÌÑ∞Í∞Ä ÌñâÏÑ± ÌëúÎ©¥ÏùÑ Ìñ•ÌïòÎèÑÎ°ù ÌöåÏ†Ñ
                        crater.lookAt(0, 0, 0);
                        
                        planetMesh.add(crater);
                    }
                    
                    // ÌôîÏÑ±Ïùò Í∑πÏßÄÎ∞© Îàà ÎçÆÏù∏ Î™®Ïûê Ï∂îÍ∞Ä
                    const polarCapGeometry = new THREE.CircleGeometry(planet.size * 0.4, 16);
                    const polarCapMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                    
                    // Î∂ÅÍ∑π Î™®Ïûê
                    const northCap = new THREE.Mesh(polarCapGeometry, polarCapMaterial);
                    northCap.position.y = planet.size * 0.9;
                    northCap.rotation.x = Math.PI / 2;
                    planetMesh.add(northCap);
                    
                    // ÎÇ®Í∑π Î™®Ïûê (Îçî ÏûëÍ≤å)
                    const southCap = new THREE.Mesh(
                        new THREE.CircleGeometry(planet.size * 0.3, 16),
                        polarCapMaterial
                    );
                    southCap.position.y = -planet.size * 0.9;
                    southCap.rotation.x = -Math.PI / 2;
                    planetMesh.add(southCap);
                }
                // Î≥¥ÎùºÏÉâ Í∞ÄÏä§Ìòï ÌñâÏÑ± (Ïù∏Îç±Ïä§ 9)
                else if (index === 9) {
                    // Í∞ÄÏä§Ìòï ÌñâÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.5,
                        metalness: 0.4
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // Í∞ÄÏä§ ÌñâÏÑ± Ï§ÑÎ¨¥Îä¨ Ìö®Í≥º
                    for (let i = 0; i < 5; i++) {
                        const stripeHeight = planet.size * 0.15;
                        const stripeY = (i - 2) * stripeHeight * 1.2;
                        
                        const stripeGeometry = new THREE.CylinderGeometry(
                            planet.size * 1.01, 
                            planet.size * 1.01, 
                            stripeHeight, 
                            16, 
                            1, 
                            true
                        );
                        
                        // Î≤àÍ∞àÏïÑÍ∞ÄÎ©∞ Îã§Î•∏ ÏÉâÏÉÅ Ï†ÅÏö©
                        const stripeColor = i % 2 === 0 ? 0x8e44ad : 0x9b59b6;
                        const stripeMaterial = new THREE.MeshStandardMaterial({
                            color: stripeColor,
                            flatShading: true,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.y = stripeY;
                        stripe.rotation.x = Math.PI / 2;
                        
                        planetMesh.add(stripe);
                    }
                    
                    // Í∞ÄÏä§ ÌñâÏÑ± Ï£ºÎ≥Ä Ìù¨ÎØ∏Ìïú ÎßÅ Ï∂îÍ∞Ä
                    const ringGeometry = new THREE.RingGeometry(planet.size * 1.4, planet.size * 1.8, 32);
                    const ringMaterial = new THREE.MeshStandardMaterial({
                        color: 0x9b59b6,
                        flatShading: true,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planetMesh.add(ring);
                }
                // Ïñ¥ÎëêÏö¥ Ïô∏Í≥Ω ÌñâÏÑ± (Ïù∏Îç±Ïä§ 12) - Îã¨Ï≤òÎüº ÌÅ¨Î†àÏù¥ÌÑ∞Í∞Ä ÏûàÎäî ÌñâÏÑ±
                else if (index === 12) {
                    // ÌñâÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 1.0,
                        metalness: 0.1
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ÎßéÏùÄ ÌÅ¨Î†àÏù¥ÌÑ∞ Ï∂îÍ∞Ä
                    for (let i = 0; i < 25; i++) {
                        const craterSize = planet.size * (Math.random() * 0.15 + 0.05);
                        const craterGeometry = new THREE.CircleGeometry(craterSize, 8);
                        const craterMaterial = new THREE.MeshStandardMaterial({
                            color: 0x2c3e50,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const crater = new THREE.Mesh(craterGeometry, craterMaterial);
                        
                        // ÎûúÎç§ ÏúÑÏπòÏóê ÌÅ¨Î†àÏù¥ÌÑ∞ Î∞∞Ïπò
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        crater.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        crater.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        crater.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // ÌÅ¨Î†àÏù¥ÌÑ∞Í∞Ä ÌñâÏÑ± ÌëúÎ©¥ÏùÑ Ìñ•ÌïòÎèÑÎ°ù ÌöåÏ†Ñ
                        crater.lookAt(0, 0, 0);
                        
                        planetMesh.add(crater);
                    }
                }
                // ÌÅ∞ ÎÖπÏÉâ ÌñâÏÑ± (Ïù∏Îç±Ïä§ 13) - Ï†ïÍ∏ÄÌòï ÌñâÏÑ±
                else if (index === 13) {
                    // ÌñâÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ÌôòÏÉÅÏùò ÎåÄÍ∏∞Ï∏µ Ï∂îÍ∞Ä
                    const atmosphereGeometry = new THREE.SphereGeometry(planet.size * 1.05, 16, 16);
                    const atmosphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x2ecc71,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    planetMesh.add(atmosphere);
                    
                    // ÌëúÎ©¥Ïóê Ï†ïÍ∏ÄÍ≥º Ìò∏Ïàò Ï∂îÍ∞Ä
                    for (let i = 0; i < 15; i++) {
                        // Ï¥àÎ°ùÏÉâ Ï†ïÍ∏Ä Ìå®Ïπò
                        const patchSize = planet.size * (Math.random() * 0.3 + 0.1);
                        const patchGeometry = new THREE.CircleGeometry(patchSize, 8);
                        const patchMaterial = new THREE.MeshStandardMaterial({
                            color: 0x229954,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                        
                        // ÎûúÎç§ ÏúÑÏπòÏóê Ï†ïÍ∏Ä Ìå®Ïπò Î∞∞Ïπò
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        patch.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        patch.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        patch.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // Ìå®ÏπòÍ∞Ä ÌñâÏÑ± ÌëúÎ©¥ÏùÑ Ìñ•ÌïòÎèÑÎ°ù ÌöåÏ†Ñ
                        patch.lookAt(0, 0, 0);
                        
                        planetMesh.add(patch);
                        
                        // ÏùºÎ∂Ä Ìå®ÏπòÎäî Ìò∏ÏàòÎ°ú ÎßåÎì§Í∏∞
                        if (i % 3 === 0) {
                            const lakeSize = patchSize * 0.7;
                            const lakeGeometry = new THREE.CircleGeometry(lakeSize, 8);
                            const lakeMaterial = new THREE.MeshStandardMaterial({
                                color: 0x3498db,
                                flatShading: true,
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.8
                            });
                            
                            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                            lake.position.set(patch.position.x * 1.001, patch.position.y * 1.001, patch.position.z * 1.001);
                            lake.lookAt(0, 0, 0);
                            
                            planetMesh.add(lake);
                        }
                    }
                }
                // Ï£ºÌô©-Í∞àÏÉâ ÌñâÏÑ± (Ïù∏Îç±Ïä§ 14) - Ïö©Ïïî ÌñâÏÑ±
                else if (index === 14) {
                    // ÌñâÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.6,
                        metalness: 0.4,
                        emissive: 0x992d00,
                        emissiveIntensity: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // Ïö©Ïïî ÌùêÎ¶Ñ Ï∂îÍ∞Ä
                    for (let i = 0; i < 12; i++) {
                        // Ïö©Ïïî Ìå®Ïπò
                        const lavaSize = planet.size * (Math.random() * 0.25 + 0.1);
                        const lavaGeometry = new THREE.CircleGeometry(lavaSize, 8);
                        const lavaMaterial = new THREE.MeshStandardMaterial({
                            color: 0xff5500,
                            flatShading: true,
                            side: THREE.DoubleSide,
                            emissive: 0xff3300,
                            emissiveIntensity: 0.5
                        });
                        
                        const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
                        
                        // ÎûúÎç§ ÏúÑÏπòÏóê Ïö©Ïïî Î∞∞Ïπò
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        lava.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        lava.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        lava.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        lava.lookAt(0, 0, 0);
                        
                        // Ïö©Ïïî ÏãúÍ∞Å Ìö®Í≥º (Îπõ)
                        const lavaLight = new THREE.PointLight(0xff5500, 0.5, planet.size * 3);
                        lavaLight.position.set(0, 0, 0);
                        lava.add(lavaLight);
                        
                        planetMesh.add(lava);
                    }
                    
                    // ÏñáÏùÄ ÌôîÏÇ∞Ïû¨ ÎåÄÍ∏∞Ï∏µ
                    const ashGeometry = new THREE.SphereGeometry(planet.size * 1.1, 16, 16);
                    const ashMaterial = new THREE.MeshStandardMaterial({
                        color: 0x5d4037,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    
                    const ash = new THREE.Mesh(ashGeometry, ashMaterial);
                    planetMesh.add(ash);
                }
                // Ìù∞ÏÉâ ÌñâÏÑ± (Ïù∏Îç±Ïä§ 15) - ÏñºÏùå/Îàà ÌñâÏÑ±
                else if (index === 15) {
                    // ÌñâÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ÏñºÏùå Í≤∞Ï†ï Ìö®Í≥º Ï∂îÍ∞Ä
                    for (let i = 0; i < 30; i++) {
                        // ÏñºÏùå Í≤∞Ï†ï ÌòïÌÉú
                        const crystalSize = planet.size * (Math.random() * 0.15 + 0.05);
                        const crystalGeometry = new THREE.ConeGeometry(crystalSize * 0.5, crystalSize, 6);
                        const crystalMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            flatShading: true,
                            transparent: true,
                            opacity: 0.8,
                            side: THREE.DoubleSide
                        });
                        
                        const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                        
                        // ÎûúÎç§ ÏúÑÏπòÏóê Í≤∞Ï†ï Î∞∞Ïπò
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        crystal.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        crystal.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        crystal.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // Í≤∞Ï†ïÏù¥ Î∞îÍπ•Ï™ΩÏùÑ Ìñ•ÌïòÎèÑÎ°ù Î∞©Ìñ• Ï°∞Ï†ï
                        crystal.lookAt(crystal.position.x * 2, crystal.position.y * 2, crystal.position.z * 2);
                        
                        planetMesh.add(crystal);
                    }
                    
                    // Î∞òÏßùÏù¥Îäî ÏóêÎÑàÏßÄÏû• Ï∂îÍ∞Ä
                    const fieldGeometry = new THREE.SphereGeometry(planet.size * 1.15, 16, 16);
                    const fieldMaterial = new THREE.MeshStandardMaterial({
                        color: 0x84ffff,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide
                    });
                    
                    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                    planetMesh.add(field);
                }
                // Ìë∏Î•∏ÏÉâ ÏñºÏùå ÌñâÏÑ± (Ïù∏Îç±Ïä§ 17) - Î¨º/ÏñºÏùå ÌñâÏÑ±
                else if (index === 17) {
                    // ÌñâÏÑ± Î≥∏Ï≤¥
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // Î¨ºÍ≥º ÏñºÏùå Ìö®Í≥º Ï∂îÍ∞Ä
                    for (let i = 0; i < 20; i++) {
                        // ÏñºÏùå Ìå®Ïπò (Ìù∞ÏÉâ Îç©Ïñ¥Î¶¨)
                        const iceSize = planet.size * (Math.random() * 0.2 + 0.1);
                        const iceGeometry = new THREE.CircleGeometry(iceSize, 8);
                        const iceMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const ice = new THREE.Mesh(iceGeometry, iceMaterial);
                        
                        // ÎûúÎç§ ÏúÑÏπòÏóê ÏñºÏùå Î∞∞Ïπò
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        ice.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        ice.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        ice.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        ice.lookAt(0, 0, 0);
                        
                        planetMesh.add(ice);
                    }
                    
                    // Î¨º Ìö®Í≥º (Î∞òÌà¨Î™Ö Ï≤≠ÏÉâ Ï∏µ)
                    const waterGeometry = new THREE.SphereGeometry(planet.size * 1.03, 24, 24);
                    const waterMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3498db,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    
                    const water = new THREE.Mesh(waterGeometry, waterMaterial);
                    planetMesh.add(water);
                }
                else {
                    // Í∏∞Î≥∏ ÌñâÏÑ± ÏÉùÏÑ±
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 0);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                }
                
                // ÌñâÏÑ± ÏúÑÏπò ÏÑ§Ï†ï
                planetMesh.position.set(...planet.position);
                
                // ÎûúÎç§Ìïú ÌöåÏ†Ñ Ï†ÅÏö©
                planetMesh.rotation.x = Math.random() * Math.PI;
                planetMesh.rotation.y = Math.random() * Math.PI;
                planetMesh.rotation.z = Math.random() * Math.PI;
                
                scene.add(planetMesh);
                
                // Í∞ÑÎã®Ìïú Ïï†ÎãàÎ©îÏù¥ÏÖòÏùÑ ÏúÑÌïú ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò Îì±Î°ù
                const rotationSpeed = 0.001 + Math.random() * 0.001;
                const rotationAxis = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                
                // ÌñâÏÑ± ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò Îì±Î°ù
                planetMesh.updateRotation = function() {
                    planetMesh.rotateOnAxis(rotationAxis, rotationSpeed);
                };
                
                // ÌñâÏÑ±Îì§ÏùÑ Ï∂îÏ†ÅÌïòÍ∏∞ ÏúÑÌï¥ Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
                planets.push(planetMesh);
            });
            
            // ÌäπÎ≥ÑÌïú ÏùÄÌïò ÏÉùÏÑ± (Î∞∞Í≤ΩÏóê ÌÅ∞ ÏõêÌòï Íµ¨Ï°∞Î¨º)
            createGalaxy(-400, -350, -800, 0x00ffff);
        }

        // ÏùÄÌïò ÏÉùÏÑ± Ìï®Ïàò
        function createGalaxy(x, y, z, color) {
            const particleCount = 1500; // ÏûÖÏûê Ïàò Ï¶ùÍ∞Ä
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // ÏùÄÌïò Íµ¨Ï°∞ ÏÉùÏÑ±
            for (let i = 0; i < particleCount; i++) {
                // ÎÇòÏÑ†Ìòï ÏùÄÌïò Î™®Ïñë ÏÉùÏÑ±
                const radius = 50 + Math.random() * 200; // Î∞òÍ≤Ω Ï¶ùÍ∞Ä
                const angle = Math.random() * Math.PI * 2;
                const spiral = Math.random() * Math.PI * 6; // Îçî ÎßéÏùÄ ÎÇòÏÑ†Ìòï ÌöåÏ†Ñ
                
                const px = Math.cos(angle + spiral) * radius;
                const py = (Math.random() - 0.5) * 25;  // ÎëêÍªò Ï¶ùÍ∞Ä
                const pz = Math.sin(angle + spiral) * radius;
                
                positions.push(px, py, pz);
                
                // Ï§ëÏïôÏóêÏÑú Î©ÄÏñ¥ÏßàÏàòÎ°ù ÏÉâÏÉÅ Î≥ÄÌôî
                const distance = Math.sqrt(px*px + pz*pz) / 250;
                
                // Îã§ÏñëÌïú ÏùÄÌïò ÏÉâÏÉÅ Ï∂îÍ∞Ä
                let r, g, b;
                
                // Ï§ëÏïô Î∂ÄÎ∂ÑÏùÄ Îçî Î∞ùÍ≤å
                if (distance < 0.3) {
                    r = 0.9 - distance;
                    g = 0.8 - distance;
                    b = 1.0;
                } else {
                    // ÏùÄÌïò Ïô∏Í≥ΩÏùÄ Îçî Ìë∏Î•¥Ïä§Î¶ÑÌïòÍ≤å
                    r = 0.3 + distance * 0.4;
                    g = 0.5 + distance * 0.3;
                    b = 0.8 + distance * 0.2;
                }
                
                colors.push(r, g, b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 3.5, // ÏûÖÏûê ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                vertexColors: true
            });
            
            const galaxy = new THREE.Points(geometry, material);
            galaxy.position.set(x, y, z);
            scene.add(galaxy);
            
            // Îëê Î≤àÏß∏ ÏùÄÌïò Ï∏µ Ï∂îÍ∞Ä (Îçî ÏûëÍ≥† Î∞ùÏùÄ Ï§ëÏã¨Î∂Ä)
            const coreGeometry = new THREE.BufferGeometry();
            const corePositions = [];
            const coreColors = [];
            
            // Ï§ëÏã¨Î∂Ä ÏÉùÏÑ±
            for (let i = 0; i < 500; i++) {
                const radius = Math.random() * 60;
                const angle = Math.random() * Math.PI * 2;
                const spiral = Math.random() * Math.PI * 2;
                
                const px = Math.cos(angle + spiral) * radius;
                const py = (Math.random() - 0.5) * 10;
                const pz = Math.sin(angle + spiral) * radius;
                
                corePositions.push(px, py, pz);
                
                // Ï§ëÏã¨Î∂ÄÎäî Î∞ùÏùÄ Ìë∏Î•∏ÏÉâ/ÏûêÏ£ºÏÉâ Í≥ÑÏó¥
                const r = 0.6 + Math.random() * 0.4;
                const g = 0.4 + Math.random() * 0.3;
                const b = 0.9 + Math.random() * 0.1;
                
                coreColors.push(r, g, b);
            }
            
            coreGeometry.setAttribute('position', new THREE.Float32BufferAttribute(corePositions, 3));
            coreGeometry.setAttribute('color', new THREE.Float32BufferAttribute(coreColors, 3));
            
            const coreMaterial = new THREE.PointsMaterial({
                size: 2.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 1.0,
                vertexColors: true
            });
            
            const galaxyCore = new THREE.Points(coreGeometry, coreMaterial);
            galaxyCore.position.set(x, y, z);
            scene.add(galaxyCore);
            
            // ÏùÄÌïòÎèÑ ÌñâÏÑ±Ï≤òÎüº ÌöåÏ†ÑÌïòÍ≤å ÌïòÍ∏∞ ÏúÑÌï¥ planets Î∞∞Ïó¥Ïóê Ï∂îÍ∞Ä
            const rotationSpeed = 0.0003;
            const rotationAxis = new THREE.Vector3(0, 1, 0).normalize();
            
            galaxy.updateRotation = function() {
                galaxy.rotateOnAxis(rotationAxis, rotationSpeed);
            };
            
            galaxyCore.updateRotation = function() {
                galaxyCore.rotateOnAxis(rotationAxis, rotationSpeed * 1.5);
            };
            
            planets.push(galaxy);
            planets.push(galaxyCore);
            
            // Ï∂îÍ∞Ä: Îçî ÏûëÏùÄ ÏùÄÌïò ÏÉùÏÑ± (ÏúÑÏÑ± ÏùÄÌïò)
            if (Math.random() > 0.5) {
                createSatelliteGalaxy(x - 250, y + 100, z - 100, 0.5, 0.6);
                createSatelliteGalaxy(x + 300, y - 150, z - 150, 0.4, 0.4);
            }
            
            return galaxy;
        }
        
        // ÏÉàÎ°úÏö¥ Ìï®Ïàò: ÏúÑÏÑ± ÏùÄÌïò ÏÉùÏÑ±
        function createSatelliteGalaxy(x, y, z, scale, opacity) {
            const particleCount = 300;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // ÏûëÏùÄ ÏùÄÌïò Íµ¨Ï°∞ ÏÉùÏÑ±
            for (let i = 0; i < particleCount; i++) {
                const radius = 20 + Math.random() * 50;
                const angle = Math.random() * Math.PI * 2;
                
                const px = Math.cos(angle) * radius;
                const py = (Math.random() - 0.5) * 10;
                const pz = Math.sin(angle) * radius;
                
                positions.push(px, py, pz);
                
                // ÏúÑÏÑ± ÏùÄÌïò ÏÉâÏÉÅ
                const r = 0.5 + Math.random() * 0.5;
                const g = 0.5 + Math.random() * 0.5;
                const b = 0.8 + Math.random() * 0.2;
                
                colors.push(r, g, b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2.0 * scale,
                sizeAttenuation: true,
                transparent: true,
                opacity: opacity,
                vertexColors: true
            });
            
            const satelliteGalaxy = new THREE.Points(geometry, material);
            satelliteGalaxy.position.set(x, y, z);
            satelliteGalaxy.scale.set(scale, scale, scale);
            
            // ÏïΩÍ∞Ñ Í∏∞Ïö∏Ïù¥Í∏∞
            satelliteGalaxy.rotation.x = Math.random() * Math.PI / 4;
            satelliteGalaxy.rotation.z = Math.random() * Math.PI / 4;
            
            scene.add(satelliteGalaxy);
            
            // ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
            const rotationSpeed = 0.001;
            const rotationAxis = new THREE.Vector3(0, 1, 0).normalize();
            
            satelliteGalaxy.updateRotation = function() {
                satelliteGalaxy.rotateOnAxis(rotationAxis, rotationSpeed);
            };
            
            planets.push(satelliteGalaxy);
            
            return satelliteGalaxy;
        }

        // ÌñâÏÑ± ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updatePlanets() {
            // Î™®Îì† ÌñâÏÑ± ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
            planets.forEach(planet => {
                if (planet.updateRotation) {
                    planet.updateRotation();
                }
            });
        }
        
        // ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
        function createPlayer() {
            // ÌîåÎ†àÏù¥Ïñ¥ Í∏∞Î≥∏ ÌòïÌÉú (Íµ¨)
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            
            // ÎπõÎÇòÎäî Ïù¥ÌéôÌä∏Î•º ÏúÑÌïú Ïû¨Ïßà
            const material = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            
            player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            
            // ÏãúÏûë ÏúÑÏπò ÏÑ§Ï†ï
            const startCloud = clouds[0];
            playerY = startCloud.position.y + 1;
            player.position.set(0, playerY, 0);
            
            scene.add(player);
            
            // ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä Î∞úÍ¥ë Ìö®Í≥º
            const glow = new THREE.PointLight(0xff0000, 1, 5);
            glow.position.set(0, 0, 0);
            player.add(glow);
            
            // Îñ®Ïñ¥Ïßà Îïå ÌöåÏ†Ñ Ìö®Í≥ºÎ•º ÏúÑÌïú Ï¥àÍ∏∞Ìôî
            player.rotation.x = 0;
            player.rotation.y = 0;
            player.rotation.z = 0;
        }
        
        // Îã®Ïùº Íµ¨Î¶Ñ ÏÉùÏÑ±
        function createCloud(x, y, z, isStartCloud = false) {
            // Íµ¨Î¶Ñ Í∑∏Î£π ÏÉùÏÑ±
            const cloudGroup = new THREE.Group();
            
            // Íµ¨Î¶Ñ ÌÅ¨Í∏∞ Í≤∞Ï†ï
            let cloudSize;
            let cloudType = '';
            
            const sizeRand = Math.random();
            if (isStartCloud) {
                cloudSize = 3;
                cloudType = 'large';
            } else if (sizeRand < 0.35) {
                cloudSize = 1.8;
                cloudType = 'small';
            } else if (sizeRand > 0.8) {
                cloudSize = 3;
                cloudType = 'large';
            } else {
                cloudSize = 2.2;
                cloudType = 'medium';
            }
            
            // Î©îÏù∏ Íµ¨Î¶Ñ ÏÉùÏÑ±
            const cloudGeometry = new THREE.SphereGeometry(cloudSize, 16, 16);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.7,
                metalness: 0.2,
                flatShading: true
            });
            
            const mainCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            mainCloud.scale.y = 0.3;
            mainCloud.receiveShadow = true;
            cloudGroup.add(mainCloud);
            
            // Íµ¨Î¶Ñ Íµ∞Îç∞Íµ∞Îç∞ Ï∂îÍ∞Ä Î∂ÄÎ∂Ñ ÏÉùÏÑ±
            const puffCount = isStartCloud ? 8 : Math.floor(Math.random() * 4) + 3;
            for (let i = 0; i < puffCount; i++) {
                const puffSize = cloudSize * (Math.random() * 0.4 + 0.3);
                const puff = new THREE.Mesh(
                    new THREE.SphereGeometry(puffSize, 8, 8),
                    cloudMaterial
                );
                
                // Íµ¨Î¶Ñ Ï£ºÎ≥ÄÏóê Î∞∞Ïπò
                const angle = (i / puffCount) * Math.PI * 2;
                const radius = cloudSize * 0.8;
                puff.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * cloudSize * 0.2,
                    Math.sin(angle) * radius
                );
                
                puff.scale.y = 0.3;
                puff.receiveShadow = true;
                cloudGroup.add(puff);
            }
            
            // Íµ¨Î¶Ñ ÏúÑÏπò ÏÑ§Ï†ï
            cloudGroup.position.set(x, y, z);
            cloudGroup.cloudSize = cloudSize;
            cloudGroup.cloudType = cloudType;
            cloudGroup.landed = false;
            cloudGroup.canLand = true; // Íµ¨Î¶ÑÏóê Ï∞©ÏßÄ Í∞ÄÎä• Ïó¨Î∂Ä ÌîåÎûòÍ∑∏ Ï∂îÍ∞Ä
            
            scene.add(cloudGroup);
            clouds.push(cloudGroup);
            
            return cloudGroup;
        }
        
        // Ï¥àÍ∏∞ Íµ¨Î¶Ñ ÏÉùÏÑ± - ÏàòÏ†ïÎê®: Í∞ÑÍ≤© Îçî ÎÑìÍ≤å
        function createInitialClouds() {
            // ÏãúÏûë Íµ¨Î¶Ñ (Ï§ëÏïô ÏúÑÏπò)
            const startCloud = createCloud(0, 0, 0, true);
            startCloud.landed = true;
            
            // Ï∂îÍ∞Ä Íµ¨Î¶Ñ ÏÉùÏÑ±
            const verticalSpacing = 6.0; // Í∞ÑÍ≤© Îçî Ï¶ùÍ∞Ä (4.0 -> 6.0)
            
            for (let i = 1; i < cloudCount; i++) {
                // X ÏúÑÏπò Í≥ÑÏÇ∞
                let x;
                
                if (i === 1) {
                    // Ï≤´ Î≤àÏß∏ Íµ¨Î¶ÑÏùÄ ÏãúÏûë ÏßÄÏ†êÏóêÏÑú Ï¢Ä Îçî Î©ÄÎ¶¨
                    x = (Math.random() * 8 - 4);
                } else {
                    // Ïù¥Ï†Ñ Íµ¨Î¶Ñ Í∏∞Ï§Ä Î∞∞Ïπò
                    const prevCloud = clouds[clouds.length - 1];
                    const prevX = prevCloud.position.x;
                    
                    // Ï†ÅÏ†àÌïú Ï†êÌîÑ Í±∞Î¶¨ - Í∞ÑÍ≤© Îçî Ï¶ùÍ∞Ä
                    const jumpRange = 8.0; // Ï¶ùÍ∞Ä (6.5 -> 8.0)
                    const minX = Math.max(-10, prevX - jumpRange);
                    const maxX = Math.min(10, prevX + jumpRange);
                    
                    x = minX + Math.random() * (maxX - minX);
                }
                
                const y = verticalSpacing * i;
                const z = 0;
                createCloud(x, y, z);
            }
        }
        
        // Ï†êÌîÑ Ìï®Ïàò - ÏàòÏ†ïÎê®: Ï†êÌîÑ Ïãú Íµ¨Î¶Ñ ÌéòÏù¥ÎìúÏïÑÏõÉ
        function jump() {
            isJumping = true;
            canDoubleJump = true;
            velocityY = jumpForce;
            
            // Ï†êÌîÑ ÏÜåÎ¶¨ Ìö®Í≥º
            playJumpSound();
            
            // Ï∂îÍ∞Ä: Î∞üÍ≥† ÏûàÎäî Íµ¨Î¶Ñ Ï∞æÏïÑÏÑú ÌéòÏù¥ÎìúÏïÑÏõÉ
            fadeCurrentCloud();
        }
        
        // Ïù¥Îã® Ï†êÌîÑ Ìï®Ïàò
        function doubleJump() {
            canDoubleJump = false;
            velocityY = jumpForce * 0.85;
            
            // Ïù¥Îã® Ï†êÌîÑ ÏÜåÎ¶¨ Ìö®Í≥º
            playDoubleJumpSound();
        }
        
        // ÏÉàÎ°úÏö¥ Ìï®Ïàò: ÌòÑÏû¨ Î∞üÍ≥† ÏûàÎäî Íµ¨Î¶Ñ Ï∞æÏïÑ ÌéòÏù¥ÎìúÏïÑÏõÉ
        function fadeCurrentCloud() {
            // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπòÏóêÏÑú ÏïÑÎûòÎ°ú ÏïΩÍ∞Ñ Îñ®Ïñ¥ÏßÑ ÏúÑÏπò ÌôïÏù∏
            const playerX = player.position.x;
            const playerY = player.position.y - 1.1; // Î∞ú ÏïÑÎûò ÏúÑÏπò
            
            // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Íµ¨Î¶Ñ Ï∞æÍ∏∞
            let closestCloud = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < clouds.length; i++) {
                const cloud = clouds[i];
                
                // Ïù¥ÎØ∏ ÌéòÏù¥ÎìúÏïÑÏõÉ Ï§ëÏù∏ Íµ¨Î¶ÑÏùÄ Í±¥ÎÑàÎúÄ
                if (!cloud.canLand) continue;
                
                const distanceX = Math.abs(playerX - cloud.position.x);
                const distanceY = Math.abs(playerY - cloud.position.y);
                
                // ÏàòÌèâ Í±∞Î¶¨Í∞Ä Íµ¨Î¶Ñ ÌÅ¨Í∏∞ ÎÇ¥Ïù¥Í≥†, ÏàòÏßÅ Í±∞Î¶¨Í∞Ä Í∞ÄÍπåÏö¥ Í≤ΩÏö∞
                if (distanceX < cloud.cloudSize && distanceY < 0.5) {
                    const totalDistance = distanceX + distanceY;
                    if (totalDistance < minDistance) {
                        minDistance = totalDistance;
                        closestCloud = cloud;
                    }
                }
            }
            
            // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Íµ¨Î¶ÑÏù¥ ÏûàÏúºÎ©¥ ÌéòÏù¥ÎìúÏïÑÏõÉ
            if (closestCloud) {
                fadeOutCloud(closestCloud);
            }
        }
        
        // ÏÜåÎ¶¨ Ìö®Í≥º Ìï®Ïàò (Í∞ÑÎã®Ìïú Íµ¨ÌòÑ)
        function playJumpSound() {
            try {
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRgQMAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YeALAACAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAAgICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCA';
                audio.volume = 0.3;
                audio.play();
            } catch (e) {
                console.log('Sound not supported');
            }
        }

        // Íµ¨Î¶Ñ ÌéòÏù¥ÎìúÏïÑÏõÉ Ìö®Í≥º
        function fadeOutCloud(cloud) {
            let opacity = 1.0;
            
            // Ï¶âÏãú Íµ¨Î¶ÑÏùÑ Î∞üÏùÑ Ïàò ÏóÜÍ≤å ÏÑ§Ï†ï
            cloud.canLand = false;
            
            const fadeInterval = setInterval(() => {
                opacity -= 0.05;
                
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    // Ïù¥ÎØ∏ ÏÇ¨ÎùºÏßÑ Íµ¨Î¶ÑÏùÄ Ï†úÍ±∞ÌïòÏßÄ ÏïäÏùå (Í≤åÏûÑ Î£®ÌîÑÏóêÏÑú Ï≤òÎ¶¨)
                } else {
                    // Íµ¨Î¶ÑÏùò Î™®Îì† Î©îÏãú Ïû¨Ïßà Ìà¨Î™ÖÎèÑ Ï°∞Ï†ï
                    cloud.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.transparent = true;
                            child.material.opacity = opacity;
                        }
                    });
                }
            }, 50);
        }

        // Í≤åÏûÑ ÏÜçÎèÑ Ï¶ùÍ∞Ä
        function increaseGameSpeed() {
            if (score < 100) {
                baseGameSpeed += 0.006; // Ï¶ùÍ∞ÄÏú® ÏÉÅÌñ• (0.004 -> 0.006)
            } else if (score < 300) {
                baseGameSpeed += 0.008; // Ï¶ùÍ∞ÄÏú® ÏÉÅÌñ• (0.005 -> 0.008)
            } else {
                baseGameSpeed += 0.01; // Ï¶ùÍ∞ÄÏú® ÏÉÅÌñ• (0.006 -> 0.01)
            }
        }
        function checkCloudCollision() {
            if (!player) return false;
            
            // Ïò§Î•¥Í≥† ÏûàÏùÑ ÎïåÎäî Ï≤¥ÌÅ¨ÌïòÏßÄ ÏïäÏùå
            if (velocityY < 0) return false;
            
            let onCloud = false;
            let landedCloudIndex = -1;
            
            for (let i = 0; i < clouds.length; i++) {
                const cloud = clouds[i];
                
                // Íµ¨Î¶ÑÏóê Ï∞©ÏßÄÌï† Ïàò ÏóÜÏúºÎ©¥ Í±¥ÎÑàÎúÄ (ÌéòÏù¥ÎìúÏïÑÏõÉ Ï§ëÏù∏ Íµ¨Î¶Ñ)
                if (!cloud.canLand) continue;
                
                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Íµ¨Î¶Ñ ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨ Í≥ÑÏÇ∞
                const distanceX = Math.abs(player.position.x - cloud.position.x);
                const distanceY = player.position.y - cloud.position.y;
                const distanceZ = Math.abs(player.position.z - cloud.position.z);
                
                // ÏàòÌèâ Í±∞Î¶¨Í∞Ä Íµ¨Î¶Ñ ÌÅ¨Í∏∞ ÎÇ¥Ïù¥Í≥†, ÏàòÏßÅÏúºÎ°ú ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Íµ¨Î¶Ñ ÏúÑÏóê ÏûàÎäîÏßÄ ÌôïÏù∏
                if (distanceX < cloud.cloudSize && 
                    distanceZ < cloud.cloudSize && 
                    distanceY > 0 && distanceY < 1) {
                    
                    // Íµ¨Î¶ÑÏóê Ï∞©ÏßÄ
                    player.position.y = cloud.position.y + 1;
                    velocityY = 0;
                    isJumping = false;
                    canDoubleJump = false;
                    onCloud = true;
                    landedCloudIndex = i;
                    
                    // ÏÉàÎ°úÏö¥ Íµ¨Î¶ÑÏóê Ï∞©ÏßÄÌï† Îïå Ï†êÏàò Ï∂îÍ∞Ä
                    if (!cloud.landed) {
                        cloud.landed = true;
                        score += 10;
                        scoreDisplay.textContent = `Score: ${score}`;
                        
                        // Ï†êÏàòÏóê Îî∞Î•∏ Í≤åÏûÑ ÏÜçÎèÑ Ï¶ùÍ∞Ä
                        if (score % 30 === 0) {
                            increaseGameSpeed();
                        }
                    }
                    
                    break;
                }
            }
            
            return onCloud;
        }

        // Í≤åÏûÑ ÏãúÏûë
        function startGame() {
            // Ïù¥Ï†Ñ Í≤åÏûÑ Î¶¨ÏÖã
            resetGame();
            
            // ÌôîÎ©¥ ÏÑ§Ï†ï
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            
            if (!scene) {
                // Ï≤òÏùå ÏãúÏûë Ïãú Three.js Ï¥àÍ∏∞Ìôî
                initThree();
            } else {
                // Ïû•Î©¥ Ï†ïÎ¶¨
                while (scene.children.length > 0) {
                    const obj = scene.children[0];
                    scene.remove(obj);
                }
                
                // Í∏∞Î≥∏ ÏöîÏÜå Ïû¨ÏÉùÏÑ±
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                
                directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // Í∞úÏÑ†Îêú Ïö∞Ï£º Î∞∞Í≤Ω ÏÉùÏÑ±
                starField = createEnhancedStarField();
            }
            
            // Ï¥àÍ∏∞ Íµ¨Î¶Ñ ÏÉùÏÑ±
            createInitialClouds();
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÏÉùÏÑ±
            createPlayer();
            
            // Í≤åÏûÑ ÏãúÏûë
            gameActive = true;
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Í≤åÏûÑ Î¶¨ÏÖã
        function resetGame() {
            // Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
            clouds = [];
            planets = []; // ÌñâÏÑ± Î∞∞Ïó¥ÎèÑ Ï¥àÍ∏∞Ìôî
            score = 0;
            scoreDisplay.textContent = `Score: 0`;
            velocityY = 0;
            velocityX = 0;
            isJumping = false;
            canDoubleJump = false;
            gameSpeed = baseGameSpeed; // Ï¥àÍ∏∞ ÏÜçÎèÑÎ°ú Î¶¨ÏÖã
            isFallingAnimation = false;
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌîÑÎ†àÏûÑ Ï∑®ÏÜå
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        // Í≤åÏûÑ Î£®ÌîÑ - ÏàòÏ†ïÎê®
        function gameLoop() {
            if (!gameActive && !isFallingAnimation) return;
            
            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
            playerX = player.position.x + velocityX;
            player.position.x = playerX;
            
            // Ï§ëÎ†• Ï†ÅÏö©
            velocityY += gravity;
            player.position.y -= velocityY;
            
            // ÌôîÎ©¥ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
            if (player.position.x < -10) {
                player.position.x = -10;
            } else if (player.position.x > 10) {
                player.position.x = 10;
            }
            
            if (gameActive) {
                // Íµ¨Î¶Ñ Ï∂©Îèå Ï≤¥ÌÅ¨
                const onCloud = checkCloudCollision();
                
                // ÎÜíÏù¥Ïóê Îî∞Î•∏ Í≤åÏûÑ ÏÜçÎèÑ Ï°∞Ï†ï
                adjustSpeedByHeight();
                
                // Íµ¨Î¶Ñ Ïù¥Îèô (ÏïÑÎûòÎ°ú)
                for (let i = clouds.length - 1; i >= 0; i--) {
                    const cloud = clouds[i];
                    cloud.position.y -= gameSpeed;
                    
                    // ÌôîÎ©¥ ÏïÑÎûòÎ°ú ÎÇòÍ∞Ñ Íµ¨Î¶ÑÏù¥ÎÇò ÌîåÎ†àÏù¥Ïñ¥Î≥¥Îã§ ÎÑàÎ¨¥ ÎÇÆÏùÄ Íµ¨Î¶ÑÏùÄ Ï†úÍ±∞
                    if (cloud.position.y < -10 || cloud.position.y < player.position.y - 10) {
                        scene.remove(cloud);
                        clouds.splice(i, 1);
                        
                        // ÏÉà Íµ¨Î¶Ñ ÏÉùÏÑ±
                        // Í∞ÄÏû• ÎÜíÏùÄ Íµ¨Î¶Ñ Ï∞æÍ∏∞
                        let highestY = -Infinity;
                        let highestCloud = null;
                        
                        for (let j = 0; j < clouds.length; j++) {
                            if (clouds[j].position.y > highestY) {
                                highestY = clouds[j].position.y;
                                highestCloud = clouds[j];
                            }
                        }
                        
                        // ÏÉà Íµ¨Î¶Ñ ÏúÑÏπò Í≥ÑÏÇ∞
                        const newY = highestY + 6.0; // Í∞ÑÍ≤© Îçî Ï¶ùÍ∞Ä (4.0 -> 6.0)
                        let newX;
                        
                        if (highestCloud) {
                            const prevX = highestCloud.position.x;
                            const jumpRange = 8.0; // Ï¶ùÍ∞Ä (6.5 -> 8.0)
                            const minX = Math.max(-10, prevX - jumpRange);
                            const maxX = Math.min(10, prevX + jumpRange);
                            newX = minX + Math.random() * (maxX - minX);
                        } else {
                            newX = (Math.random() - 0.5) * 20;
                        }
                        
                        createCloud(newX, newY, 0);
                    }
                }
                
                // Í≤åÏûÑ Ïò§Î≤Ñ Ï≤¥ÌÅ¨ (ÌîåÎ†àÏù¥Ïñ¥Í∞Ä ÌôîÎ©¥ ÏïÑÎûòÎ°ú Îñ®Ïñ¥Ïßê) - ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ
                // Ï≤¥ÌÅ¨ Î≤îÏúÑÎ•º Ï†ÅÏ†àÌïòÍ≤å Ï°∞Ï†ï
                if (player.position.y < camera.position.y - 6) {
                    console.log("Player fell off - starting falling animation");
                    startFallingAnimation();
                    return;
                }
            }
            
            // Ïπ¥Î©îÎùº ÌîåÎ†àÏù¥Ïñ¥ Îî∞ÎùºÍ∞ÄÍ∏∞
            camera.position.y = player.position.y + 5;
            camera.lookAt(player.position.x, player.position.y, 0);
            
            // Î∞∞Í≤Ω Î≥Ñ ÌöåÏ†Ñ
            starField.rotation.y += 0.0001;
            
            // ÌñâÏÑ± ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
            updatePlanets();
            
            // Î†åÎçîÎßÅ
            renderer.render(scene, camera);
            
            // Îã§Ïùå ÌîÑÎ†àÏûÑ
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // Ï∂îÎùΩ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë - ÏãúÍ∞Ñ Îã®Ï∂ïÎê®
        function startFallingAnimation() {
            // Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÍ≤Ω
            gameActive = false;
            isFallingAnimation = true;
            
            // ÌòÑÏû¨ ÏßÑÌñâ Ï§ëÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ëÏßÄÌïòÍ≥† ÏãúÏûë
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖòÏùò Ï¥àÍ∏∞ ÏÉÅÌÉú ÏÑ§Ï†ï
            let fallDuration = 0;
            const maxFallDuration = 20; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏµúÎåÄ ÏßÄÏÜç ÏãúÍ∞Ñ - Ï†ÅÏ†àÌïòÍ≤å Ï°∞Ï†ï
            
            // ÌîåÎ†àÏù¥Ïñ¥ ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò Ìï®Ïàò
            const fallingAnimation = () => {
                // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏßÄÏÜç ÏãúÍ∞Ñ Ï¶ùÍ∞Ä
                fallDuration++;
                
                // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Îñ®Ïñ¥ÏßÄÎ©¥ÏÑú ÌöåÏ†Ñ - Îçî Îπ†Î•¥Í≤å
                player.rotation.x += 0.2; // ÌöåÏ†Ñ ÏÜçÎèÑ Ï¶ùÍ∞Ä (0.1 -> 0.2)
                player.rotation.z += 0.3; // ÌöåÏ†Ñ ÏÜçÎèÑ Ï¶ùÍ∞Ä (0.15 -> 0.3)
                
                // Ï§ëÎ†•ÏùÑ Ï¶ùÍ∞ÄÏãúÏºú Í∞ÄÏÜç Ìö®Í≥º
                velocityY += gravity * 1.5; // Ï§ëÎ†• Ìö®Í≥º Ï¶ùÍ∞Ä (1.2 -> 1.5)
                player.position.y -= velocityY;
                
                // Ïπ¥Î©îÎùºÍ∞Ä ÌîåÎ†àÏù¥Ïñ¥Î•º ÏïΩÍ∞Ñ ÎäêÏä®ÌïòÍ≤å Îî∞ÎùºÍ∞ê
                camera.position.y = player.position.y + 8;
                camera.lookAt(player.position);
                
                // ÌñâÏÑ± ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Ï∂îÍ∞Ä)
                updatePlanets();
                
                // Î†åÎçîÎßÅ
                renderer.render(scene, camera);
                
                // Ï∂©Î∂ÑÌûà Îñ®Ïñ¥Ï°åÍ±∞ÎÇò ÏµúÎåÄ ÏßÄÏÜç ÏãúÍ∞ÑÏóê ÎèÑÎã¨ÌïòÎ©¥ Í≤åÏûÑ Ïò§Î≤Ñ Ìò∏Ï∂ú
                if (player.position.y < camera.position.y - 8 || fallDuration > maxFallDuration) { // Ï≤¥ÌÅ¨ Ï°∞Í±¥ Ï°∞Ï†ï
                    console.log("Falling animation ended - calling gameOver()");
                    isFallingAnimation = false;
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    
                    // Ï¶âÏãú Í≤åÏûÑÏò§Î≤Ñ Ìò∏Ï∂ú (ÏßÄÏó∞ ÏãúÍ∞Ñ Ï†úÍ±∞)
                    gameOver();
                    return;
                }
                
                // Îã§Ïùå ÌîÑÎ†àÏûÑ ÏöîÏ≤≠
                animationFrameId = requestAnimationFrame(fallingAnimation);
            };
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
            animationFrameId = requestAnimationFrame(fallingAnimation);
        }

        // Í≤åÏûÑ Ïò§Î≤Ñ Ìï®Ïàò - ÏàòÏ†ï ÏóÜÏùå
        function gameOver() {
            console.log("Game over function called");
            
            // Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÍ≤Ω - Î™®Îì† ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            gameActive = false;
            isFallingAnimation = false;
            
            // Î™®Îì† Ïï†ÎãàÎ©îÏù¥ÏÖò Ï§ëÏßÄ - Îçî ÌôïÏã§ÌïòÍ≤å
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // ÏµúÍ≥† Ï†êÏàò ÏóÖÎç∞Ïù¥Ìä∏
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                highScoreDisplay.textContent = `High Score: ${highScore}`;
            }
            
            // Ï†êÏàò ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
            finalScore.textContent = `Score: ${score}`;
            highScoreElement.textContent = `High Score: ${highScore}`;
            
            // Í≤åÏûÑ Ïò§Î≤Ñ ÌôîÎ©¥ ÌëúÏãú - ÌïÑÏàò CSS Î≥ÄÍ≤Ω
            gameOverScreen.style.display = 'flex';
            gameOverScreen.style.opacity = '1';
            gameOverScreen.style.pointerEvents = 'auto';
            gameOverScreen.style.visibility = 'visible';
            
            console.log("Game over screen should be visible now");
        }
    </script>
</body>
</html>

        function playDoubleJumpSound() {
            try {
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRgQMAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YeALAACAgICAgICAgICAgICAgICAgIC