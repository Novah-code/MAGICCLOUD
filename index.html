<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cloud Hopper 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000033;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 100;
        }
        #high-score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 100;
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 200;
        }
        #start-screen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff;
        }
        #start-button {
            font-size: 24px;
            padding: 15px 30px;
            background-color: #00aaff;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 10px #00aaff;
            transition: all 0.3s ease;
        }
        #start-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00aaff, 0 0 25px #00aaff;
        }
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9); /* ë” ë¶ˆíˆ¬ëª…í•˜ê²Œ */
            z-index: 1000; /* ìµœìƒìœ„ ë ˆì´ì–´ */
            pointer-events: auto;
        }
        #game-over h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0033, 0 0 20px #ff0033;
            animation: pulsate 1.5s infinite alternate;
        }
        @keyframes pulsate {
            0% { text-shadow: 0 0 10px #ff0033, 0 0 20px #ff0033; }
            100% { text-shadow: 0 0 15px #ff0033, 0 0 30px #ff0033, 0 0 40px #ff0033; }
        }
        #final-score {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        #high-score {
            color: gold;
            font-size: 24px;
            margin-bottom: 30px;
            text-shadow: 0 0 10px gold;
        }
        #restart-button {
            font-size: 24px;
            padding: 15px 30px;
            background-color: #ff0033;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 10px #ff0033;
            transition: all 0.3s ease;
        }
        #restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff0033, 0 0 25px #ff0033;
        }
        .instructions {
            color: white;
            max-width: 600px;
            text-align: center;
            margin: 20px 0 30px 0;
            font-size: 18px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-display">Score: 0</div>
        <div id="high-score-display">High Score: 0</div>
        
        <div id="start-screen">
            <h1>Cloud Hopper 3D</h1>
            <div class="instructions">
                <p>Jump from cloud to cloud and don't fall!</p>
                <p>Use LEFT/RIGHT arrow keys to move</p>
                <p>Press UP arrow to jump (press again for double jump)</p>
            </div>
            <button id="start-button">START</button>
        </div>
        
        <div id="game-over">
            <h1>Game Over</h1>
            <div id="final-score">Score: 0</div>
            <div id="high-score">High Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Vibe Jam 2025 ì°¸ê°€ ë§í¬ -->
    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">ğŸ•¹ï¸ Vibe Jam 2025</a>

    <script>
        // DOM ìš”ì†Œ
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const highScoreDisplay = document.getElementById('high-score-display');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const gameOverScreen = document.getElementById('game-over');
        const finalScore = document.getElementById('final-score');
        const highScoreElement = document.getElementById('high-score');
        const restartButton = document.getElementById('restart-button');
        
        // ì‹œì‘ ì‹œ ê²Œì„ì˜¤ë²„ í™”ë©´ ìˆ¨ê¸°ê¸°
        gameOverScreen.style.display = 'none';
        
        // Three.js ë³€ìˆ˜
        let scene, camera, renderer;
        let player;
        let clouds = [];
        let planets = []; // í–‰ì„± ë°°ì—´ ì¶”ê°€
        let starField;
        let directionalLight;
        
        // ê²Œì„ ë³€ìˆ˜
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let gameActive = false;
        let isFallingAnimation = false;
        let playerX = 0;
        let playerY = 0;
        let playerZ = 0;
        let velocityY = 0;
        let velocityX = 0;
        let gravity = 0.015;
        let jumpForce = -0.4;
        let isJumping = false;
        let canDoubleJump = false;
        let animationFrameId;
        let cloudCount = 9; // êµ¬ë¦„ ìˆ˜ ì¦ê°€ (6 -> 9)
        let gameSpeed = 0.08; // ì´ˆê¸° ì†ë„
        let baseGameSpeed = 0.08; // ê¸°ë³¸ ê²Œì„ ì†ë„
        
        // ìµœì´ˆ í•˜ì´ìŠ¤ì½”ì–´ í‘œì‹œ
        highScoreDisplay.textContent = `High Score: ${highScore}`;
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        
        document.addEventListener('keydown', function(event) {
            if (!gameActive) return;
            
            if (event.key === 'ArrowLeft') {
                velocityX = -0.15;
            }
            if (event.key === 'ArrowRight') {
                velocityX = 0.15;
            }
            if (event.key === 'ArrowUp') {
                if (!isJumping) {
                    jump();
                } else if (canDoubleJump) {
                    doubleJump();
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                velocityX = 0;
            }
        });
        
        // Three.js ì´ˆê¸°í™”
        function initThree() {
            // ì”¬ ìƒì„±
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000033);
            
            // ì¹´ë©”ë¼ ìƒì„±
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            // ë Œë”ëŸ¬ ìƒì„±
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            
            // ì¡°ëª… ì„¤ì •
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);
            
            // ê°œì„ ëœ ìš°ì£¼ ë°°ê²½ ìƒì„±
            starField = createEnhancedStarField();
            
            // ì°½ í¬ê¸° ë³€ê²½ ì´ë²¤íŠ¸
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // ìƒˆë¡œìš´ í•¨ìˆ˜: ë†’ì´ì— ë”°ë¥¸ ê²Œì„ ì†ë„ ì¡°ì •
        function adjustSpeedByHeight() {
            // ì‹œì‘ ë†’ì´ë¥¼ 0ìœ¼ë¡œ ê¸°ì¤€ ì‚¼ìŒ
            const currentHeight = player.position.y;
            
            // ë†’ì´ì— ë”°ë¥¸ ì¶”ê°€ ì†ë„ (100 ë‹¨ìœ„ë§ˆë‹¤ 0.02ì”© ì¦ê°€)
            const heightMultiplier = 0.0002;
            const additionalSpeed = currentHeight * heightMultiplier;
            
            // ìµœì¢… ê²Œì„ ì†ë„ ê³„ì‚° (ìµœì†Œ ì†ë„ëŠ” baseGameSpeed ìœ ì§€)
            gameSpeed = baseGameSpeed + additionalSpeed;
            
            // ìµœëŒ€ ì†ë„ ì œí•œ (ë„ˆë¬´ ë¹¨ë¼ì§€ì§€ ì•Šë„ë¡)
            const maxSpeed = 0.3;
            if (gameSpeed > maxSpeed) {
                gameSpeed = maxSpeed;
            }
        }
        
        // ë‹¤ì–‘í•œ ìƒ‰ìƒê³¼ í¬ê¸°ì˜ ë³„ê³¼ í–‰ì„±ì´ ìˆëŠ” ìš°ì£¼ ë°°ê²½ ìƒì„±
        function createEnhancedStarField() {
            // ê¸°ì¡´ ë³„ ë°°ê²½ ìƒì„±
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const starPositions = [];
            const starColors = [];
            const starSizes = [];
            
            // ë” ë‹¤ì–‘í•œ ìƒ‰ìƒì˜ ë³„ë“¤ ìƒì„±
            for (let i = 0; i < starCount; i++) {
                const x = (Math.random() - 0.5) * 1000;
                const y = (Math.random() - 0.5) * 1000;
                const z = (Math.random() - 0.5) * 1000;
                starPositions.push(x, y, z);
                
                // ë³„ í¬ê¸° ë‹¤ì–‘í™”
                const size = Math.random() * 2 + 0.5;
                starSizes.push(size);
                
                // ë³„ ìƒ‰ìƒ ë‹¤ì–‘í™” (í°ìƒ‰, ë…¸ë€ìƒ‰, íŒŒë€ìƒ‰, ë¹¨ê°„ìƒ‰ ë“±)
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    // ëŒ€ë¶€ë¶„ í°ìƒ‰~ë…¸ë€ìƒ‰ ë³„
                    const shade = 0.7 + Math.random() * 0.3;
                    starColors.push(shade, shade, Math.max(0.7, shade - 0.2));
                } else if (colorChoice < 0.8) {
                    // ì•½ê°„ì˜ í‘¸ë¥¸ ë³„
                    starColors.push(0.7, 0.7, 1);
                } else if (colorChoice < 0.9) {
                    // ì•½ê°„ì˜ ë¶‰ì€ ë³„
                    starColors.push(1, 0.7, 0.7);
                } else {
                    // ì•½ê°„ì˜ ì²­ë¡ìƒ‰ ë³„
                    starColors.push(0.7, 1, 1);
                }
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                size: 1.5,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
            
            // í–‰ì„± ì¶”ê°€ (í”½ì…€í™”ëœ ìŠ¤íƒ€ì¼)
            addPixelPlanets();
            
            return starField;
        }

        // í”½ì…€í™”ëœ í–‰ì„± ì¶”ê°€ í•¨ìˆ˜
        function addPixelPlanets() {
            // í–‰ì„±ì˜ ì¢…ë¥˜ì™€ ìƒ‰ìƒ ì •ì˜
            const planetTypes = [
                // ê¸°ì¡´ í–‰ì„±ë“¤
                { size: 8, color: 0x3498db, position: [-180, 100, -400] },  // íŒŒë€ìƒ‰ í–‰ì„±
                { size: 12, color: 0x8e44ad, position: [200, -150, -350] }, // ë³´ë¼ìƒ‰ í–‰ì„±
                { size: 6, color: 0x1abc9c, position: [-100, -200, -300] }, // ì²­ë¡ìƒ‰ í–‰ì„±
                { size: 10, color: 0xe74c3c, position: [150, 180, -380] },  // ë¹¨ê°„ìƒ‰ í–‰ì„±
                { size: 15, color: 0xf1c40f, position: [-220, -120, -420] }, // ë…¸ë€ìƒ‰ í–‰ì„±
                { size: 30, color: 0x3498db, position: [400, 50, -600] },   // ì§€êµ¬ (í° íŒŒë€ìƒ‰ í–‰ì„±)
                { size: 25, color: 0xf39c12, position: [320, -80, -500] },   // í† ì„± (í° ì£¼í™©ìƒ‰ í–‰ì„±)
                
                // ì€í•˜ ì™¼ìª½ì— ì¶”ê°€í•œ í–‰ì„±ë“¤
                { size: 18, color: 0xe74c3c, position: [-350, 50, -550] },   // ë¶‰ì€ í™”ì„±í˜• í–‰ì„±
                { size: 5, color: 0xf1c40f, position: [-280, 120, -480] },   // ì‘ì€ ë…¸ë€ìƒ‰ í–‰ì„±
                { size: 14, color: 0x9b59b6, position: [-400, -100, -520] }, // ë³´ë¼ìƒ‰ ê°€ìŠ¤í˜• í–‰ì„±
                { size: 8, color: 0x1abc9c, position: [-320, -180, -450] },  // ì²­ë¡ìƒ‰ ì–¼ìŒ í–‰ì„±
                { size: 7, color: 0xe67e22, position: [-430, 150, -500] },   // ì‘ì€ ì£¼í™©ìƒ‰ í–‰ì„±
                { size: 20, color: 0x34495e, position: [-500, -50, -650] },   // ì–´ë‘ìš´ ì™¸ê³½ í–‰ì„±
                
                // ê· í˜•ì„ ìœ„í•´ ì˜¤ë¥¸ìª½ í–‰ì„±ë“¤ê³¼ ë°˜ëŒ€ ìœ„ì¹˜ì— ì¶”ê°€í•  ìƒˆë¡œìš´ í–‰ì„±ë“¤
                { size: 28, color: 0x27ae60, position: [-420, -40, -580] },  // í° ë…¹ìƒ‰ í–‰ì„± (ì§€êµ¬ ë°˜ëŒ€í¸)
                { size: 22, color: 0xd35400, position: [-380, 100, -520] },  // í° ì£¼í™©-ê°ˆìƒ‰ í–‰ì„± (í† ì„± ë°˜ëŒ€í¸)
                { size: 16, color: 0xecf0f1, position: [-300, 200, -480] },  // ì¤‘ê°„ í¬ê¸° í°ìƒ‰ í–‰ì„±
                { size: 10, color: 0xf1c40f, position: [-250, -220, -400] }, // ì‘ì€ ë…¸ë€ìƒ‰ í–‰ì„±
                { size: 13, color: 0x2980b9, position: [-450, -150, -550] }  // ì¤‘ê°„ í¬ê¸° í‘¸ë¥¸ìƒ‰ ì–¼ìŒ í–‰ì„±
            ];
            
            // ê° í–‰ì„± ìƒì„±
            planetTypes.forEach((planet, index) => {
                let planetMesh;
                
                // ì§€êµ¬ í–‰ì„± (ì¸ë±ìŠ¤ 5)
                if (index === 5) {
                    // ì§€êµ¬ ìƒì„± - í”½ì…€í™”ëœ ëª¨ìŠµì„ ìœ„í•´ ë‚®ì€ ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜ ì‚¬ìš©
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    
                    // í”½ì…€í™”ëœ ì§€êµ¬ ì¬ì§ˆ
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.7,
                        metalness: 0.3
                    });
                    
                    // ì§€êµ¬ ëŒ€ë¥™ íš¨ê³¼ë¥¼ ìœ„í•œ ì¶”ê°€ ë””í…Œì¼
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ëŒ€ë¥™ì„ í‘œí˜„í•˜ê¸° ìœ„í•œ ëœë¤ íŒ¨í„´
                    const continentGeometry = new THREE.IcosahedronGeometry(planet.size * 1.01, 1);
                    const continentMaterial = new THREE.MeshStandardMaterial({
                        color: 0x2ecc71, // ì´ˆë¡ìƒ‰ ëŒ€ë¥™
                        flatShading: true,
                        roughness: 0.9,
                        metalness: 0.1,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    // ëŒ€ë¥™ ë©”ì‹œ ë³€í˜•í•˜ì—¬ ì¼ë¶€ë§Œ ë³´ì´ê²Œ
                    const continentMesh = new THREE.Mesh(continentGeometry, continentMaterial);
                    
                    // ì •ì  ì¼ë¶€ë§Œ ë³´ì´ê²Œ ì¡°ì ˆ
                    const positionAttribute = continentGeometry.getAttribute('position');
                    const vertex = new THREE.Vector3();
                    
                    // ë²„í…ìŠ¤ ì‘ì—…ì„ ìœ„í•œ ì„ì‹œ ë°°ì—´
                    const positions = [];
                    const visible = [];
                    
                    for (let i = 0; i < positionAttribute.count; i++) {
                        visible.push(Math.random() > 0.6); // 60% í™•ë¥ ë¡œ ëŒ€ë¥™ ë¶€ë¶„ ìˆ¨ê¹€
                        
                        vertex.fromBufferAttribute(positionAttribute, i);
                        if (!visible[i]) {
                            // í•´ë‹¹ ë²„í…ìŠ¤ ì•ˆë³´ì´ê²Œ (ë¬¼ ì†ìœ¼ë¡œ)
                            vertex.multiplyScalar(0.98);
                        }
                        
                        positions.push(vertex.x, vertex.y, vertex.z);
                    }
                    
                    continentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    planetMesh.add(continentMesh);
                }
                // í† ì„± í–‰ì„± (ì¸ë±ìŠ¤ 6)
                else if (index === 6) {
                    // í† ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // í† ì„± ê³ ë¦¬ ì¶”ê°€
                    const ringGeometry = new THREE.RingGeometry(planet.size * 1.3, planet.size * 1.7, 32);
                    const ringMaterial = new THREE.MeshStandardMaterial({
                        color: 0xf5deb3,
                        flatShading: true,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2.5; // ê³ ë¦¬ ê¸°ìš¸ì´ê¸°
                    planetMesh.add(ring);
                    
                    // ì¶”ê°€ ì–‡ì€ ê³ ë¦¬
                    const thinRingGeometry = new THREE.RingGeometry(planet.size * 1.8, planet.size * 1.85, 32);
                    const thinRingMaterial = new THREE.MeshStandardMaterial({
                        color: 0xd2b48c,
                        flatShading: true,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    const thinRing = new THREE.Mesh(thinRingGeometry, thinRingMaterial);
                    thinRing.rotation.x = Math.PI / 2.5;
                    planetMesh.add(thinRing);
                }
                // ë¶‰ì€ í™”ì„±í˜• í–‰ì„± (ì¸ë±ìŠ¤ 7)
                else if (index === 7) {
                    // í™”ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.9,
                        metalness: 0.1
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // í‘œë©´ í¬ë ˆì´í„° ì¶”ê°€
                    for (let i = 0; i < 12; i++) {
                        const craterSize = planet.size * (Math.random() * 0.1 + 0.05);
                        const craterGeometry = new THREE.CircleGeometry(craterSize, 8);
                        const craterMaterial = new THREE.MeshStandardMaterial({
                            color: 0xc0392b,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const crater = new THREE.Mesh(craterGeometry, craterMaterial);
                        
                        // ëœë¤ ìœ„ì¹˜ì— í¬ë ˆì´í„° ë°°ì¹˜
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        crater.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        crater.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        crater.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // í¬ë ˆì´í„°ê°€ í–‰ì„± í‘œë©´ì„ í–¥í•˜ë„ë¡ íšŒì „
                        crater.lookAt(0, 0, 0);
                        
                        planetMesh.add(crater);
                    }
                    
                    // í™”ì„±ì˜ ê·¹ì§€ë°© ëˆˆ ë®ì¸ ëª¨ì ì¶”ê°€
                    const polarCapGeometry = new THREE.CircleGeometry(planet.size * 0.4, 16);
                    const polarCapMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        flatShading: true,
                        side: THREE.DoubleSide
                    });
                    
                    // ë¶ê·¹ ëª¨ì
                    const northCap = new THREE.Mesh(polarCapGeometry, polarCapMaterial);
                    northCap.position.y = planet.size * 0.9;
                    northCap.rotation.x = Math.PI / 2;
                    planetMesh.add(northCap);
                    
                    // ë‚¨ê·¹ ëª¨ì (ë” ì‘ê²Œ)
                    const southCap = new THREE.Mesh(
                        new THREE.CircleGeometry(planet.size * 0.3, 16),
                        polarCapMaterial
                    );
                    southCap.position.y = -planet.size * 0.9;
                    southCap.rotation.x = -Math.PI / 2;
                    planetMesh.add(southCap);
                }
                // ë³´ë¼ìƒ‰ ê°€ìŠ¤í˜• í–‰ì„± (ì¸ë±ìŠ¤ 9)
                else if (index === 9) {
                    // ê°€ìŠ¤í˜• í–‰ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.5,
                        metalness: 0.4
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ê°€ìŠ¤ í–‰ì„± ì¤„ë¬´ëŠ¬ íš¨ê³¼
                    for (let i = 0; i < 5; i++) {
                        const stripeHeight = planet.size * 0.15;
                        const stripeY = (i - 2) * stripeHeight * 1.2;
                        
                        const stripeGeometry = new THREE.CylinderGeometry(
                            planet.size * 1.01, 
                            planet.size * 1.01, 
                            stripeHeight, 
                            16, 
                            1, 
                            true
                        );
                        
                        // ë²ˆê°ˆì•„ê°€ë©° ë‹¤ë¥¸ ìƒ‰ìƒ ì ìš©
                        const stripeColor = i % 2 === 0 ? 0x8e44ad : 0x9b59b6;
                        const stripeMaterial = new THREE.MeshStandardMaterial({
                            color: stripeColor,
                            flatShading: true,
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.y = stripeY;
                        stripe.rotation.x = Math.PI / 2;
                        
                        planetMesh.add(stripe);
                    }
                    
                    // ê°€ìŠ¤ í–‰ì„± ì£¼ë³€ í¬ë¯¸í•œ ë§ ì¶”ê°€
                    const ringGeometry = new THREE.RingGeometry(planet.size * 1.4, planet.size * 1.8, 32);
                    const ringMaterial = new THREE.MeshStandardMaterial({
                        color: 0x9b59b6,
                        flatShading: true,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    planetMesh.add(ring);
                }
                // ì–´ë‘ìš´ ì™¸ê³½ í–‰ì„± (ì¸ë±ìŠ¤ 12) - ë‹¬ì²˜ëŸ¼ í¬ë ˆì´í„°ê°€ ìˆëŠ” í–‰ì„±
                else if (index === 12) {
                    // í–‰ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 1.0,
                        metalness: 0.1
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ë§ì€ í¬ë ˆì´í„° ì¶”ê°€
                    for (let i = 0; i < 25; i++) {
                        const craterSize = planet.size * (Math.random() * 0.15 + 0.05);
                        const craterGeometry = new THREE.CircleGeometry(craterSize, 8);
                        const craterMaterial = new THREE.MeshStandardMaterial({
                            color: 0x2c3e50,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const crater = new THREE.Mesh(craterGeometry, craterMaterial);
                        
                        // ëœë¤ ìœ„ì¹˜ì— í¬ë ˆì´í„° ë°°ì¹˜
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        crater.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        crater.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        crater.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // í¬ë ˆì´í„°ê°€ í–‰ì„± í‘œë©´ì„ í–¥í•˜ë„ë¡ íšŒì „
                        crater.lookAt(0, 0, 0);
                        
                        planetMesh.add(crater);
                    }
                }
                // í° ë…¹ìƒ‰ í–‰ì„± (ì¸ë±ìŠ¤ 13) - ì •ê¸€í˜• í–‰ì„±
                else if (index === 13) {
                    // í–‰ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // í™˜ìƒì˜ ëŒ€ê¸°ì¸µ ì¶”ê°€
                    const atmosphereGeometry = new THREE.SphereGeometry(planet.size * 1.05, 16, 16);
                    const atmosphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x2ecc71,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide
                    });
                    
                    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    planetMesh.add(atmosphere);
                    
                    // í‘œë©´ì— ì •ê¸€ê³¼ í˜¸ìˆ˜ ì¶”ê°€
                    for (let i = 0; i < 15; i++) {
                        // ì´ˆë¡ìƒ‰ ì •ê¸€ íŒ¨ì¹˜
                        const patchSize = planet.size * (Math.random() * 0.3 + 0.1);
                        const patchGeometry = new THREE.CircleGeometry(patchSize, 8);
                        const patchMaterial = new THREE.MeshStandardMaterial({
                            color: 0x229954,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const patch = new THREE.Mesh(patchGeometry, patchMaterial);
                        
                        // ëœë¤ ìœ„ì¹˜ì— ì •ê¸€ íŒ¨ì¹˜ ë°°ì¹˜
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        patch.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        patch.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        patch.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // íŒ¨ì¹˜ê°€ í–‰ì„± í‘œë©´ì„ í–¥í•˜ë„ë¡ íšŒì „
                        patch.lookAt(0, 0, 0);
                        
                        planetMesh.add(patch);
                        
                        // ì¼ë¶€ íŒ¨ì¹˜ëŠ” í˜¸ìˆ˜ë¡œ ë§Œë“¤ê¸°
                        if (i % 3 === 0) {
                            const lakeSize = patchSize * 0.7;
                            const lakeGeometry = new THREE.CircleGeometry(lakeSize, 8);
                            const lakeMaterial = new THREE.MeshStandardMaterial({
                                color: 0x3498db,
                                flatShading: true,
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.8
                            });
                            
                            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                            lake.position.set(patch.position.x * 1.001, patch.position.y * 1.001, patch.position.z * 1.001);
                            lake.lookAt(0, 0, 0);
                            
                            planetMesh.add(lake);
                        }
                    }
                }
                // ì£¼í™©-ê°ˆìƒ‰ í–‰ì„± (ì¸ë±ìŠ¤ 14) - ìš©ì•” í–‰ì„±
                else if (index === 14) {
                    // í–‰ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.6,
                        metalness: 0.4,
                        emissive: 0x992d00,
                        emissiveIntensity: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ìš©ì•” íë¦„ ì¶”ê°€
                    for (let i = 0; i < 12; i++) {
                        // ìš©ì•” íŒ¨ì¹˜
                        const lavaSize = planet.size * (Math.random() * 0.25 + 0.1);
                        const lavaGeometry = new THREE.CircleGeometry(lavaSize, 8);
                        const lavaMaterial = new THREE.MeshStandardMaterial({
                            color: 0xff5500,
                            flatShading: true,
                            side: THREE.DoubleSide,
                            emissive: 0xff3300,
                            emissiveIntensity: 0.5
                        });
                        
                        const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
                        
                        // ëœë¤ ìœ„ì¹˜ì— ìš©ì•” ë°°ì¹˜
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        lava.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        lava.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        lava.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        lava.lookAt(0, 0, 0);
                        
                        // ìš©ì•” ì‹œê° íš¨ê³¼ (ë¹›)
                        const lavaLight = new THREE.PointLight(0xff5500, 0.5, planet.size * 3);
                        lavaLight.position.set(0, 0, 0);
                        lava.add(lavaLight);
                        
                        planetMesh.add(lava);
                    }
                    
                    // ì–‡ì€ í™”ì‚°ì¬ ëŒ€ê¸°ì¸µ
                    const ashGeometry = new THREE.SphereGeometry(planet.size * 1.1, 16, 16);
                    const ashMaterial = new THREE.MeshStandardMaterial({
                        color: 0x5d4037,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    
                    const ash = new THREE.Mesh(ashGeometry, ashMaterial);
                    planetMesh.add(ash);
                }
                // í°ìƒ‰ í–‰ì„± (ì¸ë±ìŠ¤ 15) - ì–¼ìŒ/ëˆˆ í–‰ì„±
                else if (index === 15) {
                    // í–‰ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.3,
                        metalness: 0.8
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ì–¼ìŒ ê²°ì • íš¨ê³¼ ì¶”ê°€
                    for (let i = 0; i < 30; i++) {
                        // ì–¼ìŒ ê²°ì • í˜•íƒœ
                        const crystalSize = planet.size * (Math.random() * 0.15 + 0.05);
                        const crystalGeometry = new THREE.ConeGeometry(crystalSize * 0.5, crystalSize, 6);
                        const crystalMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            flatShading: true,
                            transparent: true,
                            opacity: 0.8,
                            side: THREE.DoubleSide
                        });
                        
                        const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                        
                        // ëœë¤ ìœ„ì¹˜ì— ê²°ì • ë°°ì¹˜
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        crystal.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        crystal.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        crystal.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        // ê²°ì •ì´ ë°”ê¹¥ìª½ì„ í–¥í•˜ë„ë¡ ë°©í–¥ ì¡°ì •
                        crystal.lookAt(crystal.position.x * 2, crystal.position.y * 2, crystal.position.z * 2);
                        
                        planetMesh.add(crystal);
                    }
                    
                    // ë°˜ì§ì´ëŠ” ì—ë„ˆì§€ì¥ ì¶”ê°€
                    const fieldGeometry = new THREE.SphereGeometry(planet.size * 1.15, 16, 16);
                    const fieldMaterial = new THREE.MeshStandardMaterial({
                        color: 0x84ffff,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide
                    });
                    
                    const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
                    planetMesh.add(field);
                }
                // í‘¸ë¥¸ìƒ‰ ì–¼ìŒ í–‰ì„± (ì¸ë±ìŠ¤ 17) - ë¬¼/ì–¼ìŒ í–‰ì„±
                else if (index === 17) {
                    // í–‰ì„± ë³¸ì²´
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 1);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                    
                    // ë¬¼ê³¼ ì–¼ìŒ íš¨ê³¼ ì¶”ê°€
                    for (let i = 0; i < 20; i++) {
                        // ì–¼ìŒ íŒ¨ì¹˜ (í°ìƒ‰ ë©ì–´ë¦¬)
                        const iceSize = planet.size * (Math.random() * 0.2 + 0.1);
                        const iceGeometry = new THREE.CircleGeometry(iceSize, 8);
                        const iceMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            flatShading: true,
                            side: THREE.DoubleSide
                        });
                        
                        const ice = new THREE.Mesh(iceGeometry, iceMaterial);
                        
                        // ëœë¤ ìœ„ì¹˜ì— ì–¼ìŒ ë°°ì¹˜
                        const phi = Math.acos(-1 + (2 * Math.random()));
                        const theta = 2 * Math.PI * Math.random();
                        
                        ice.position.x = planet.size * Math.sin(phi) * Math.cos(theta) * 1.01;
                        ice.position.y = planet.size * Math.sin(phi) * Math.sin(theta) * 1.01;
                        ice.position.z = planet.size * Math.cos(phi) * 1.01;
                        
                        ice.lookAt(0, 0, 0);
                        
                        planetMesh.add(ice);
                    }
                    
                    // ë¬¼ íš¨ê³¼ (ë°˜íˆ¬ëª… ì²­ìƒ‰ ì¸µ)
                    const waterGeometry = new THREE.SphereGeometry(planet.size * 1.03, 24, 24);
                    const waterMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3498db,
                        flatShading: false,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    
                    const water = new THREE.Mesh(waterGeometry, waterMaterial);
                    planetMesh.add(water);
                }
                else {
                    // ê¸°ë³¸ í–‰ì„± ìƒì„±
                    const geometry = new THREE.IcosahedronGeometry(planet.size, 0);
                    const material = new THREE.MeshStandardMaterial({
                        color: planet.color,
                        flatShading: true,
                        roughness: 0.8,
                        metalness: 0.2
                    });
                    
                    planetMesh = new THREE.Mesh(geometry, material);
                }
                
                // í–‰ì„± ìœ„ì¹˜ ì„¤ì •
                planetMesh.position.set(...planet.position);
                
                // ëœë¤í•œ íšŒì „ ì ìš©
                planetMesh.rotation.x = Math.random() * Math.PI;
                planetMesh.rotation.y = Math.random() * Math.PI;
                planetMesh.rotation.z = Math.random() * Math.PI;
                
                scene.add(planetMesh);
                
                // ê°„ë‹¨í•œ ì• ë‹ˆë©”ì´ì…˜ì„ ìœ„í•œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ë“±ë¡
                const rotationSpeed = 0.001 + Math.random() * 0.001;
                const rotationAxis = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                
                // í–‰ì„± íšŒì „ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ë“±ë¡
                planetMesh.updateRotation = function() {
                    planetMesh.rotateOnAxis(rotationAxis, rotationSpeed);
                };
                
                // í–‰ì„±ë“¤ì„ ì¶”ì í•˜ê¸° ìœ„í•´ ë°°ì—´ì— ì¶”ê°€
                planets.push(planetMesh);
            });
            
            // íŠ¹ë³„í•œ ì€í•˜ ìƒì„± (ë°°ê²½ì— í° ì›í˜• êµ¬ì¡°ë¬¼)
            createGalaxy(-400, -350, -800, 0x00ffff);
        }

        // ì€í•˜ ìƒì„± í•¨ìˆ˜
        function createGalaxy(x, y, z, color) {
            const particleCount = 1500; // ì…ì ìˆ˜ ì¦ê°€
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // ì€í•˜ êµ¬ì¡° ìƒì„±
            for (let i = 0; i < particleCount; i++) {
                // ë‚˜ì„ í˜• ì€í•˜ ëª¨ì–‘ ìƒì„±
                const radius = 50 + Math.random() * 200; // ë°˜ê²½ ì¦ê°€
                const angle = Math.random() * Math.PI * 2;
                const spiral = Math.random() * Math.PI * 6; // ë” ë§ì€ ë‚˜ì„ í˜• íšŒì „
                
                const px = Math.cos(angle + spiral) * radius;
                const py = (Math.random() - 0.5) * 25;  // ë‘ê»˜ ì¦ê°€
                const pz = Math.sin(angle + spiral) * radius;
                
                positions.push(px, py, pz);
                
                // ì¤‘ì•™ì—ì„œ ë©€ì–´ì§ˆìˆ˜ë¡ ìƒ‰ìƒ ë³€í™”
                const distance = Math.sqrt(px*px + pz*pz) / 250;
                
                // ë‹¤ì–‘í•œ ì€í•˜ ìƒ‰ìƒ ì¶”ê°€
                let r, g, b;
                
                // ì¤‘ì•™ ë¶€ë¶„ì€ ë” ë°ê²Œ
                if (distance < 0.3) {
                    r = 0.9 - distance;
                    g = 0.8 - distance;
                    b = 1.0;
                } else {
                    // ì€í•˜ ì™¸ê³½ì€ ë” í‘¸ë¥´ìŠ¤ë¦„í•˜ê²Œ
                    r = 0.3 + distance * 0.4;
                    g = 0.5 + distance * 0.3;
                    b = 0.8 + distance * 0.2;
                }
                
                colors.push(r, g, b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 3.5, // ì…ì í¬ê¸° ì¦ê°€
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                vertexColors: true
            });
            
            const galaxy = new THREE.Points(geometry, material);
            galaxy.position.set(x, y, z);
            scene.add(galaxy);
            
            // ë‘ ë²ˆì§¸ ì€í•˜ ì¸µ ì¶”ê°€ (ë” ì‘ê³  ë°ì€ ì¤‘ì‹¬ë¶€)
            const coreGeometry = new THREE.BufferGeometry();
            const corePositions = [];
            const coreColors = [];
            
            // ì¤‘ì‹¬ë¶€ ìƒì„±
            for (let i = 0; i < 500; i++) {
                const radius = Math.random() * 60;
                const angle = Math.random() * Math.PI * 2;
                const spiral = Math.random() * Math.PI * 2;
                
                const px = Math.cos(angle + spiral) * radius;
                const py = (Math.random() - 0.5) * 10;
                const pz = Math.sin(angle + spiral) * radius;
                
                corePositions.push(px, py, pz);
                
                // ì¤‘ì‹¬ë¶€ëŠ” ë°ì€ í‘¸ë¥¸ìƒ‰/ìì£¼ìƒ‰ ê³„ì—´
                const r = 0.6 + Math.random() * 0.4;
                const g = 0.4 + Math.random() * 0.3;
                const b = 0.9 + Math.random() * 0.1;
                
                coreColors.push(r, g, b);
            }
            
            coreGeometry.setAttribute('position', new THREE.Float32BufferAttribute(corePositions, 3));
            coreGeometry.setAttribute('color', new THREE.Float32BufferAttribute(coreColors, 3));
            
            const coreMaterial = new THREE.PointsMaterial({
                size: 2.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 1.0,
                vertexColors: true
            });
            
            const galaxyCore = new THREE.Points(coreGeometry, coreMaterial);
            galaxyCore.position.set(x, y, z);
            scene.add(galaxyCore);
            
            // ì€í•˜ë„ í–‰ì„±ì²˜ëŸ¼ íšŒì „í•˜ê²Œ í•˜ê¸° ìœ„í•´ planets ë°°ì—´ì— ì¶”ê°€
            const rotationSpeed = 0.0003;
            const rotationAxis = new THREE.Vector3(0, 1, 0).normalize();
            
            galaxy.updateRotation = function() {
                galaxy.rotateOnAxis(rotationAxis, rotationSpeed);
            };
            
            galaxyCore.updateRotation = function() {
                galaxyCore.rotateOnAxis(rotationAxis, rotationSpeed * 1.5);
            };
            
            planets.push(galaxy);
            planets.push(galaxyCore);
            
            // ì¶”ê°€: ë” ì‘ì€ ì€í•˜ ìƒì„± (ìœ„ì„± ì€í•˜)
            if (Math.random() > 0.5) {
                createSatelliteGalaxy(x - 250, y + 100, z - 100, 0.5, 0.6);
                createSatelliteGalaxy(x + 300, y - 150, z - 150, 0.4, 0.4);
            }
            
            return galaxy;
        }
        
        // ìƒˆë¡œìš´ í•¨ìˆ˜: ìœ„ì„± ì€í•˜ ìƒì„±
        function createSatelliteGalaxy(x, y, z, scale, opacity) {
            const particleCount = 300;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            // ì‘ì€ ì€í•˜ êµ¬ì¡° ìƒì„±
            for (let i = 0; i < particleCount; i++) {
                const radius = 20 + Math.random() * 50;
                const angle = Math.random() * Math.PI * 2;
                
                const px = Math.cos(angle) * radius;
                const py = (Math.random() - 0.5) * 10;
                const pz = Math.sin(angle) * radius;
                
                positions.push(px, py, pz);
                
                // ìœ„ì„± ì€í•˜ ìƒ‰ìƒ
                const r = 0.5 + Math.random() * 0.5;
                const g = 0.5 + Math.random() * 0.5;
                const b = 0.8 + Math.random() * 0.2;
                
                colors.push(r, g, b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2.0 * scale,
                sizeAttenuation: true,
                transparent: true,
                opacity: opacity,
                vertexColors: true
            });
            
            const satelliteGalaxy = new THREE.Points(geometry, material);
            satelliteGalaxy.position.set(x, y, z);
            satelliteGalaxy.scale.set(scale, scale, scale);
            
            // ì•½ê°„ ê¸°ìš¸ì´ê¸°
            satelliteGalaxy.rotation.x = Math.random() * Math.PI / 4;
            satelliteGalaxy.rotation.z = Math.random() * Math.PI / 4;
            
            scene.add(satelliteGalaxy);
            
            // íšŒì „ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            const rotationSpeed = 0.001;
            const rotationAxis = new THREE.Vector3(0, 1, 0).normalize();
            
            satelliteGalaxy.updateRotation = function() {
                satelliteGalaxy.rotateOnAxis(rotationAxis, rotationSpeed);
            };
            
            planets.push(satelliteGalaxy);
            
            return satelliteGalaxy;
        }

        // í–‰ì„± ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePlanets() {
            // ëª¨ë“  í–‰ì„± íšŒì „ ì—…ë°ì´íŠ¸
            planets.forEach(planet => {
                if (planet.updateRotation) {
                    planet.updateRotation();
                }
            });
        }
        
        // í”Œë ˆì´ì–´ ìƒì„±
        function createPlayer() {
            // í”Œë ˆì´ì–´ ê¸°ë³¸ í˜•íƒœ (êµ¬)
            const geometry = new THREE.SphereGeometry(0.5, 32, 32);
            
            // ë¹›ë‚˜ëŠ” ì´í™íŠ¸ë¥¼ ìœ„í•œ ì¬ì§ˆ
            const material = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });
            
            player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            
            // ì‹œì‘ ìœ„ì¹˜ ì„¤ì •
            const startCloud = clouds[0];
            playerY = startCloud.position.y + 1;
            player.position.set(0, playerY, 0);
            
            scene.add(player);
            
            // í”Œë ˆì´ì–´ ì£¼ë³€ ë°œê´‘ íš¨ê³¼
            const glow = new THREE.PointLight(0xff0000, 1, 5);
            glow.position.set(0, 0, 0);
            player.add(glow);
            
            // ë–¨ì–´ì§ˆ ë•Œ íšŒì „ íš¨ê³¼ë¥¼ ìœ„í•œ ì´ˆê¸°í™”
            player.rotation.x = 0;
            player.rotation.y = 0;
            player.rotation.z = 0;
        }
        
        // ë‹¨ì¼ êµ¬ë¦„ ìƒì„±
        function createCloud(x, y, z, isStartCloud = false) {
            // êµ¬ë¦„ ê·¸ë£¹ ìƒì„±
            const cloudGroup = new THREE.Group();
            
            // êµ¬ë¦„ í¬ê¸° ê²°ì •
            let cloudSize;
            let cloudType = '';
            
            const sizeRand = Math.random();
            if (isStartCloud) {
                cloudSize = 3;
                cloudType = 'large';
            } else if (sizeRand < 0.35) {
                cloudSize = 1.8;
                cloudType = 'small';
            } else if (sizeRand > 0.8) {
                cloudSize = 3;
                cloudType = 'large';
            } else {
                cloudSize = 2.2;
                cloudType = 'medium';
            }
            
            // ë©”ì¸ êµ¬ë¦„ ìƒì„±
            const cloudGeometry = new THREE.SphereGeometry(cloudSize, 16, 16);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.7,
                metalness: 0.2,
                flatShading: true
            });
            
            const mainCloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            mainCloud.scale.y = 0.3;
            mainCloud.receiveShadow = true;
            cloudGroup.add(mainCloud);
            
            // êµ¬ë¦„ êµ°ë°êµ°ë° ì¶”ê°€ ë¶€ë¶„ ìƒì„±
            const puffCount = isStartCloud ? 8 : Math.floor(Math.random() * 4) + 3;
            for (let i = 0; i < puffCount; i++) {
                const puffSize = cloudSize * (Math.random() * 0.4 + 0.3);
                const puff = new THREE.Mesh(
                    new THREE.SphereGeometry(puffSize, 8, 8),
                    cloudMaterial
                );
                
                // êµ¬ë¦„ ì£¼ë³€ì— ë°°ì¹˜
                const angle = (i / puffCount) * Math.PI * 2;
                const radius = cloudSize * 0.8;
                puff.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * cloudSize * 0.2,
                    Math.sin(angle) * radius
                );
                
                puff.scale.y = 0.3;
                puff.receiveShadow = true;
                cloudGroup.add(puff);
            }
            
            // êµ¬ë¦„ ìœ„ì¹˜ ì„¤ì •
            cloudGroup.position.set(x, y, z);
            cloudGroup.cloudSize = cloudSize;
            cloudGroup.cloudType = cloudType;
            cloudGroup.landed = false;
            cloudGroup.canLand = true; // êµ¬ë¦„ì— ì°©ì§€ ê°€ëŠ¥ ì—¬ë¶€ í”Œë˜ê·¸ ì¶”ê°€
            
            scene.add(cloudGroup);
            clouds.push(cloudGroup);
            
            return cloudGroup;
        }
        
        // ì´ˆê¸° êµ¬ë¦„ ìƒì„± - ìˆ˜ì •ë¨: ê°„ê²© ë” ë„“ê²Œ
        function createInitialClouds() {
            // ì‹œì‘ êµ¬ë¦„ (ì¤‘ì•™ ìœ„ì¹˜)
            const startCloud = createCloud(0, 0, 0, true);
            startCloud.landed = true;
            
            // ì¶”ê°€ êµ¬ë¦„ ìƒì„±
            const verticalSpacing = 6.0; // ê°„ê²© ë” ì¦ê°€ (4.0 -> 6.0)
            
            for (let i = 1; i < cloudCount; i++) {
                // X ìœ„ì¹˜ ê³„ì‚°
                let x;
                
                if (i === 1) {
                    // ì²« ë²ˆì§¸ êµ¬ë¦„ì€ ì‹œì‘ ì§€ì ì—ì„œ ì¢€ ë” ë©€ë¦¬
                    x = (Math.random() * 8 - 4);
                } else {
                    // ì´ì „ êµ¬ë¦„ ê¸°ì¤€ ë°°ì¹˜
                    const prevCloud = clouds[clouds.length - 1];
                    const prevX = prevCloud.position.x;
                    
                    // ì ì ˆí•œ ì í”„ ê±°ë¦¬ - ê°„ê²© ë” ì¦ê°€
                    const jumpRange = 8.0; // ì¦ê°€ (6.5 -> 8.0)
                    const minX = Math.max(-10, prevX - jumpRange);
                    const maxX = Math.min(10, prevX + jumpRange);
                    
                    x = minX + Math.random() * (maxX - minX);
                }
                
                const y = verticalSpacing * i;
                const z = 0;
                createCloud(x, y, z);
            }
        }
        
        // ì í”„ í•¨ìˆ˜ - ìˆ˜ì •ë¨: ì í”„ ì‹œ êµ¬ë¦„ í˜ì´ë“œì•„ì›ƒ
        function jump() {
            isJumping = true;
            canDoubleJump = true;
            velocityY = jumpForce;
            
            // ì í”„ ì†Œë¦¬ íš¨ê³¼
            playJumpSound();
            
            // ì¶”ê°€: ë°Ÿê³  ìˆëŠ” êµ¬ë¦„ ì°¾ì•„ì„œ í˜ì´ë“œì•„ì›ƒ
            fadeCurrentCloud();
        }
        
        // ì´ë‹¨ ì í”„ í•¨ìˆ˜
        function doubleJump() {
            canDoubleJump = false;
            velocityY = jumpForce * 0.85;
            
            // ì´ë‹¨ ì í”„ ì†Œë¦¬ íš¨ê³¼
            playDoubleJumpSound();
        }
        
        // ìƒˆë¡œìš´ í•¨ìˆ˜: í˜„ì¬ ë°Ÿê³  ìˆëŠ” êµ¬ë¦„ ì°¾ì•„ í˜ì´ë“œì•„ì›ƒ
        function fadeCurrentCloud() {
            // í”Œë ˆì´ì–´ ìœ„ì¹˜ì—ì„œ ì•„ë˜ë¡œ ì•½ê°„ ë–¨ì–´ì§„ ìœ„ì¹˜ í™•ì¸
            const playerX = player.position.x;
            const playerY = player.position.y - 1.1; // ë°œ ì•„ë˜ ìœ„ì¹˜
            
            // ê°€ì¥ ê°€ê¹Œìš´ êµ¬ë¦„ ì°¾ê¸°
            let closestCloud = null;
            let minDistance = Infinity;
            
            for (let i = 0; i < clouds.length; i++) {
                const cloud = clouds[i];
                
                // ì´ë¯¸ í˜ì´ë“œì•„ì›ƒ ì¤‘ì¸ êµ¬ë¦„ì€ ê±´ë„ˆëœ€
                if (!cloud.canLand) continue;
                
                const distanceX = Math.abs(playerX - cloud.position.x);
                const distanceY = Math.abs(playerY - cloud.position.y);
                
                // ìˆ˜í‰ ê±°ë¦¬ê°€ êµ¬ë¦„ í¬ê¸° ë‚´ì´ê³ , ìˆ˜ì§ ê±°ë¦¬ê°€ ê°€ê¹Œìš´ ê²½ìš°
                if (distanceX < cloud.cloudSize && distanceY < 0.5) {
                    const totalDistance = distanceX + distanceY;
                    if (totalDistance < minDistance) {
                        minDistance = totalDistance;
                        closestCloud = cloud;
                    }
                }
            }
            
            // ê°€ì¥ ê°€ê¹Œìš´ êµ¬ë¦„ì´ ìˆìœ¼ë©´ í˜ì´ë“œì•„ì›ƒ
            if (closestCloud) {
                fadeOutCloud(closestCloud);
            }
        }
        
        // ì†Œë¦¬ íš¨ê³¼ í•¨ìˆ˜ (ê°„ë‹¨í•œ êµ¬í˜„)
        function playJumpSound() {
            try {
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRgQMAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YeALAACAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAAgICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCA';
                audio.volume = 0.3;
                audio.play();
            } catch (e) {
                console.log('Sound not supported');
            }
        }

        // êµ¬ë¦„ í˜ì´ë“œì•„ì›ƒ íš¨ê³¼
        function fadeOutCloud(cloud) {
            let opacity = 1.0;
            
            // ì¦‰ì‹œ êµ¬ë¦„ì„ ë°Ÿì„ ìˆ˜ ì—†ê²Œ ì„¤ì •
            cloud.canLand = false;
            
            const fadeInterval = setInterval(() => {
                opacity -= 0.05;
                
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    // ì´ë¯¸ ì‚¬ë¼ì§„ êµ¬ë¦„ì€ ì œê±°í•˜ì§€ ì•ŠìŒ (ê²Œì„ ë£¨í”„ì—ì„œ ì²˜ë¦¬)
                } else {
                    // êµ¬ë¦„ì˜ ëª¨ë“  ë©”ì‹œ ì¬ì§ˆ íˆ¬ëª…ë„ ì¡°ì •
                    cloud.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.transparent = true;
                            child.material.opacity = opacity;
                        }
                    });
                }
            }, 50);
        }

        // ê²Œì„ ì†ë„ ì¦ê°€
        function increaseGameSpeed() {
            if (score < 100) {
                baseGameSpeed += 0.006; // ì¦ê°€ìœ¨ ìƒí–¥ (0.004 -> 0.006)
            } else if (score < 300) {
                baseGameSpeed += 0.008; // ì¦ê°€ìœ¨ ìƒí–¥ (0.005 -> 0.008)
            } else {
                baseGameSpeed += 0.01; // ì¦ê°€ìœ¨ ìƒí–¥ (0.006 -> 0.01)
            }
        }
        function checkCloudCollision() {
            if (!player) return false;
            
            // ì˜¤ë¥´ê³  ìˆì„ ë•ŒëŠ” ì²´í¬í•˜ì§€ ì•ŠìŒ
            if (velocityY < 0) return false;
            
            let onCloud = false;
            let landedCloudIndex = -1;
            
            for (let i = 0; i < clouds.length; i++) {
                const cloud = clouds[i];
                
                // êµ¬ë¦„ì— ì°©ì§€í•  ìˆ˜ ì—†ìœ¼ë©´ ê±´ë„ˆëœ€ (í˜ì´ë“œì•„ì›ƒ ì¤‘ì¸ êµ¬ë¦„)
                if (!cloud.canLand) continue;
                
                // í”Œë ˆì´ì–´ì™€ êµ¬ë¦„ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                const distanceX = Math.abs(player.position.x - cloud.position.x);
                const distanceY = player.position.y - cloud.position.y;
                const distanceZ = Math.abs(player.position.z - cloud.position.z);
                
                // ìˆ˜í‰ ê±°ë¦¬ê°€ êµ¬ë¦„ í¬ê¸° ë‚´ì´ê³ , ìˆ˜ì§ìœ¼ë¡œ í”Œë ˆì´ì–´ê°€ êµ¬ë¦„ ìœ„ì— ìˆëŠ”ì§€ í™•ì¸
                if (distanceX < cloud.cloudSize && 
                    distanceZ < cloud.cloudSize && 
                    distanceY > 0 && distanceY < 1) {
                    
                    // êµ¬ë¦„ì— ì°©ì§€
                    player.position.y = cloud.position.y + 1;
                    velocityY = 0;
                    isJumping = false;
                    canDoubleJump = false;
                    onCloud = true;
                    landedCloudIndex = i;
                    
                    // ìƒˆë¡œìš´ êµ¬ë¦„ì— ì°©ì§€í•  ë•Œ ì ìˆ˜ ì¶”ê°€
                    if (!cloud.landed) {
                        cloud.landed = true;
                        score += 10;
                        scoreDisplay.textContent = `Score: ${score}`;
                        
                        // ì ìˆ˜ì— ë”°ë¥¸ ê²Œì„ ì†ë„ ì¦ê°€
                        if (score % 30 === 0) {
                            increaseGameSpeed();
                        }
                    }
                    
                    break;
                }
            }
            
            return onCloud;
        }

        // ê²Œì„ ì‹œì‘
        function startGame() {
            // ì´ì „ ê²Œì„ ë¦¬ì…‹
            resetGame();
            
            // í™”ë©´ ì„¤ì •
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            
            if (!scene) {
                // ì²˜ìŒ ì‹œì‘ ì‹œ Three.js ì´ˆê¸°í™”
                initThree();
            } else {
                // ì¥ë©´ ì •ë¦¬
                while (scene.children.length > 0) {
                    const obj = scene.children[0];
                    scene.remove(obj);
                }
                
                // ê¸°ë³¸ ìš”ì†Œ ì¬ìƒì„±
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                
                directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 10, 7.5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);
                
                // ê°œì„ ëœ ìš°ì£¼ ë°°ê²½ ìƒì„±
                starField = createEnhancedStarField();
            }
            
            // ì´ˆê¸° êµ¬ë¦„ ìƒì„±
            createInitialClouds();
            
            // í”Œë ˆì´ì–´ ìƒì„±
            createPlayer();
            
            // ê²Œì„ ì‹œì‘
            gameActive = true;
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ë¦¬ì…‹
        function resetGame() {
            // ë³€ìˆ˜ ì´ˆê¸°í™”
            clouds = [];
            planets = []; // í–‰ì„± ë°°ì—´ë„ ì´ˆê¸°í™”
            score = 0;
            scoreDisplay.textContent = `Score: 0`;
            velocityY = 0;
            velocityX = 0;
            isJumping = false;
            canDoubleJump = false;
            gameSpeed = baseGameSpeed; // ì´ˆê¸° ì†ë„ë¡œ ë¦¬ì…‹
            isFallingAnimation = false;
            
            // ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ ì·¨ì†Œ
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        // ê²Œì„ ë£¨í”„ - ìˆ˜ì •ë¨
        function gameLoop() {
            if (!gameActive && !isFallingAnimation) return;
            
            // í”Œë ˆì´ì–´ ì´ë™
            playerX = player.position.x + velocityX;
            player.position.x = playerX;
            
            // ì¤‘ë ¥ ì ìš©
            velocityY += gravity;
            player.position.y -= velocityY;
            
            // í™”ë©´ ê²½ê³„ ì²´í¬
            if (player.position.x < -10) {
                player.position.x = -10;
            } else if (player.position.x > 10) {
                player.position.x = 10;
            }
            
            if (gameActive) {
                // êµ¬ë¦„ ì¶©ëŒ ì²´í¬
                const onCloud = checkCloudCollision();
                
                // ë†’ì´ì— ë”°ë¥¸ ê²Œì„ ì†ë„ ì¡°ì •
                adjustSpeedByHeight();
                
                // êµ¬ë¦„ ì´ë™ (ì•„ë˜ë¡œ)
                for (let i = clouds.length - 1; i >= 0; i--) {
                    const cloud = clouds[i];
                    cloud.position.y -= gameSpeed;
                    
                    // í™”ë©´ ì•„ë˜ë¡œ ë‚˜ê°„ êµ¬ë¦„ì´ë‚˜ í”Œë ˆì´ì–´ë³´ë‹¤ ë„ˆë¬´ ë‚®ì€ êµ¬ë¦„ì€ ì œê±°
                    if (cloud.position.y < -10 || cloud.position.y < player.position.y - 10) {
                        scene.remove(cloud);
                        clouds.splice(i, 1);
                        
                        // ìƒˆ êµ¬ë¦„ ìƒì„±
                        // ê°€ì¥ ë†’ì€ êµ¬ë¦„ ì°¾ê¸°
                        let highestY = -Infinity;
                        let highestCloud = null;
                        
                        for (let j = 0; j < clouds.length; j++) {
                            if (clouds[j].position.y > highestY) {
                                highestY = clouds[j].position.y;
                                highestCloud = clouds[j];
                            }
                        }
                        
                        // ìƒˆ êµ¬ë¦„ ìœ„ì¹˜ ê³„ì‚°
                        const newY = highestY + 6.0; // ê°„ê²© ë” ì¦ê°€ (4.0 -> 6.0)
                        let newX;
                        
                        if (highestCloud) {
                            const prevX = highestCloud.position.x;
                            const jumpRange = 8.0; // ì¦ê°€ (6.5 -> 8.0)
                            const minX = Math.max(-10, prevX - jumpRange);
                            const maxX = Math.min(10, prevX + jumpRange);
                            newX = minX + Math.random() * (maxX - minX);
                        } else {
                            newX = (Math.random() - 0.5) * 20;
                        }
                        
                        createCloud(newX, newY, 0);
                    }
                }
                
                // ê²Œì„ ì˜¤ë²„ ì²´í¬ (í”Œë ˆì´ì–´ê°€ í™”ë©´ ì•„ë˜ë¡œ ë–¨ì–´ì§) - ìˆ˜ì •ëœ ë¶€ë¶„
                // ì²´í¬ ë²”ìœ„ë¥¼ ì ì ˆí•˜ê²Œ ì¡°ì •
                if (player.position.y < camera.position.y - 6) {
                    console.log("Player fell off - starting falling animation");
                    startFallingAnimation();
                    return;
                }
            }
            
            // ì¹´ë©”ë¼ í”Œë ˆì´ì–´ ë”°ë¼ê°€ê¸°
            camera.position.y = player.position.y + 5;
            camera.lookAt(player.position.x, player.position.y, 0);
            
            // ë°°ê²½ ë³„ íšŒì „
            starField.rotation.y += 0.0001;
            
            // í–‰ì„± íšŒì „ ì—…ë°ì´íŠ¸
            updatePlanets();
            
            // ë Œë”ë§
            renderer.render(scene, camera);
            
            // ë‹¤ìŒ í”„ë ˆì„
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ì¶”ë½ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ - ì‹œê°„ ë‹¨ì¶•ë¨
        function startFallingAnimation() {
            // ê²Œì„ ìƒíƒœ ë³€ê²½
            gameActive = false;
            isFallingAnimation = true;
            
            // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€í•˜ê³  ì‹œì‘
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // ì• ë‹ˆë©”ì´ì…˜ì˜ ì´ˆê¸° ìƒíƒœ ì„¤ì •
            let fallDuration = 0;
            const maxFallDuration = 20; // ì• ë‹ˆë©”ì´ì…˜ ìµœëŒ€ ì§€ì† ì‹œê°„ - ì ì ˆí•˜ê²Œ ì¡°ì •
            
            // í”Œë ˆì´ì–´ íšŒì „ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
            const fallingAnimation = () => {
                // ì• ë‹ˆë©”ì´ì…˜ ì§€ì† ì‹œê°„ ì¦ê°€
                fallDuration++;
                
                // í”Œë ˆì´ì–´ê°€ ë–¨ì–´ì§€ë©´ì„œ íšŒì „ - ë” ë¹ ë¥´ê²Œ
                player.rotation.x += 0.2; // íšŒì „ ì†ë„ ì¦ê°€ (0.1 -> 0.2)
                player.rotation.z += 0.3; // íšŒì „ ì†ë„ ì¦ê°€ (0.15 -> 0.3)
                
                // ì¤‘ë ¥ì„ ì¦ê°€ì‹œì¼œ ê°€ì† íš¨ê³¼
                velocityY += gravity * 1.5; // ì¤‘ë ¥ íš¨ê³¼ ì¦ê°€ (1.2 -> 1.5)
                player.position.y -= velocityY;
                
                // ì¹´ë©”ë¼ê°€ í”Œë ˆì´ì–´ë¥¼ ì•½ê°„ ëŠìŠ¨í•˜ê²Œ ë”°ë¼ê°
                camera.position.y = player.position.y + 8;
                camera.lookAt(player.position);
                
                // í–‰ì„± íšŒì „ ì—…ë°ì´íŠ¸ (ì¶”ê°€)
                updatePlanets();
                
                // ë Œë”ë§
                renderer.render(scene, camera);
                
                // ì¶©ë¶„íˆ ë–¨ì–´ì¡Œê±°ë‚˜ ìµœëŒ€ ì§€ì† ì‹œê°„ì— ë„ë‹¬í•˜ë©´ ê²Œì„ ì˜¤ë²„ í˜¸ì¶œ
                if (player.position.y < camera.position.y - 8 || fallDuration > maxFallDuration) { // ì²´í¬ ì¡°ê±´ ì¡°ì •
                    console.log("Falling animation ended - calling gameOver()");
                    isFallingAnimation = false;
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    
                    // ì¦‰ì‹œ ê²Œì„ì˜¤ë²„ í˜¸ì¶œ (ì§€ì—° ì‹œê°„ ì œê±°)
                    gameOver();
                    return;
                }
                
                // ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
                animationFrameId = requestAnimationFrame(fallingAnimation);
            };
            
            // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            animationFrameId = requestAnimationFrame(fallingAnimation);
        }

        // ê²Œì„ ì˜¤ë²„ í•¨ìˆ˜ - ìˆ˜ì • ì—†ìŒ
        function gameOver() {
            console.log("Game over function called");
            
            // ê²Œì„ ìƒíƒœ ë³€ê²½ - ëª¨ë“  ìƒíƒœ ì´ˆê¸°í™”
            gameActive = false;
            isFallingAnimation = false;
            
            // ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì§€ - ë” í™•ì‹¤í•˜ê²Œ
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // ìµœê³  ì ìˆ˜ ì—…ë°ì´íŠ¸
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                highScoreDisplay.textContent = `High Score: ${highScore}`;
            }
            
            // ì ìˆ˜ í‘œì‹œ ì—…ë°ì´íŠ¸
            finalScore.textContent = `Score: ${score}`;
            highScoreElement.textContent = `High Score: ${highScore}`;
            
            // ê²Œì„ ì˜¤ë²„ í™”ë©´ í‘œì‹œ - í•„ìˆ˜ CSS ë³€ê²½
            gameOverScreen.style.display = 'flex';
            gameOverScreen.style.opacity = '1';
            gameOverScreen.style.pointerEvents = 'auto';
            gameOverScreen.style.visibility = 'visible';
            
            console.log("Game over screen should be visible now");
        }
    </script>
</body>
</html>

        function playDoubleJumpSound() {
            try {
                const audio = new Audio();
                audio.src = 'data:audio/wav;base64,UklGRgQMAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YeALAACAgICAgICAgICAgICAgICAgIC